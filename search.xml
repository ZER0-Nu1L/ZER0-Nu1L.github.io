<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【飞蛾扑火】PowerShell 终端美化踩坑</title>
    <url>/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p>美，是一种感知。<br>
潜藏在每个人生命中，<br>
当它被挖掘，被激发，<br>
便会变成一种使人安定的力量。<br>
它不仅能带来感官上的触动，<br>
也是历练生命、丰沛情感、释放思想的源泉。<br>
—— 蒋勋</p>
</blockquote>
<p>对于 PowerShell 美化的折腾，其实在两三个月前我曾经做过一次，那个时候还是在期末考试期间。因为过度沉迷，以及涌现出了的意料之外的终端乱码，花费了不少时间，最后为了赶复习进度而不了了之。</p>
<p>这次又一次在 <code>zn</code> 的安利下，开始飞蛾扑火。</p>
<p>在这里分享 PowerShell 美化的思路，希望帮助大家避过坑，以及记录一些自己的感悟。</p>
<p><img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308121225697.png" alt="image-20200308121225697"></p>
<a id="more"></a>
<h1>PowerShell 终端美化思路</h1>
<blockquote>
<p>PowerShell 默认的终端是很简单的，并没有考虑美化。从实用角度基本是够用的，但在实用的基础上，很多人希望能有更好的使用体验，所以一大堆应用涌现。</p>
</blockquote>
<p>终端美化的基本思路有：</p>
<ol>
<li>对 PowerShell 的字体等进行修改；</li>
<li>在 PowerShell 上安装并使用 oh-my-posh；</li>
<li>改用第三方终端，如 Fluent Terminal、Hyper、Terminus 等。</li>
</ol>
<p>⭐️ ​其中值得注意的是，PowerShell 安装 oh-my-posh 后很可能出现“乱码”的现象，这是字体缺位导致的，建议改用支持大量其他字体的第三方终端，一劳永逸。</p>
<h2 id="结论置顶">结论置顶</h2>
<blockquote>
<p>这里先呈现结论，结论的依据会在后面详细解释。</p>
</blockquote>
<h3 id="效果图">效果图</h3>
<p><img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308103044933.png" alt="image-20200308103044933"></p>
<h3 id="思路">思路</h3>
<p>PowerShell 自身不支持 oh-my-zsh 的一些字体，会导致乱码，故使用 Powershell 第三方终端（如 Fluent Terminal）+oh-my-zsh 的方案。</p>
<ol>
<li>下载安装 Fluent Terminal；</li>
<li>在 PowerShell 下安装 oh-my-zsh，选择自己喜欢的主题，通过更改 <code>$proflie</code> 指定的文件，将 oh-my-zsh 的设置在每次启动 PowerShell 的时候自动加载。</li>
<li>下载 oh-my-zsh 需要的字体，将 Fluent Terminal 的字体修改；</li>
<li>更改 VSCode 的终端字体设置，使之同等美化。</li>
</ol>
<h2 id="修改-PowerShell-的终端">修改 PowerShell 的终端</h2>
<p>这是 PowerShell 和 cmd 自身提供的属性设置。（标题栏右键）</p>
<img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308101500526.png" alt="image-20200308101500526" style="zoom:80%;">
<p>但是局限性非常大，可用的字体非常少。cmd 和 PowerShell 对字体的要求很严苛，即使你安装了一大堆的字体，在 <code>&quot;Windows PowerShell&quot; 属性 </code> 中的 <code>字体</code> 选项卡下，能看到的字体也就几个。</p>
<p>也有博客对自定义字体有“研究成果”，详见：<a href="https://walterlv.github.io/post/customize-fonts-of-command-window.html#%E6%8E%A8%E8%8D%90%E5%8F%AF%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93" target="_blank" rel="noopener">自定义 Windows PowerShell 和 cmd 的字体</a>。</p>
<h2 id="安装使用-oh-my-zsh">安装使用 oh-my-zsh</h2>
<p>安装步骤和使用的教程非常多，笔者也是直接参照网络上的教程安装的，这里不再赘述。<br>
但使用的时候会发现，没有 Linux 下 zsh 的效果，甚至出现如下近乎“乱码”的现象：</p>
<img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308104054220.png" alt="image-20200308104054220" style="zoom: 67%;">
<p>看看其他主题的情况？</p>
<p><img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308110644627.png" alt="image-20200308110644627"></p>
<p>发现“乱码”其实只有一两种字符。<br>
⭐️ 其实是因为对应的字符在当前字体下是不存在的，而支持这些字符的字体在 cmd 和 PowerShell 严苛要求下的字体几乎是不存在的。<br>
✔️ 所以需要使用第三方Powershell 终端，才能还原 zsh 在 Linux 下的风采。</p>
<h2 id="使用第三方-PowerShell-终端">使用第三方 PowerShell 终端</h2>
<h3 id="下载安装-Fluent-Terminal">下载安装 Fluent Terminal</h3>
<p>PowerShell 终端非常多，如 Fluent Terminal、Hyper、Terminus 等。</p>
<p>其中很受推荐的其中一个是 Fluent Terminal，是利用 UWP 技术打造的颜值超高的终端模拟器。不过在 UWP 应用市场并找不到，要去 <a href="https://github.com/felixse/FluentTerminal/releases" target="_blank" rel="noopener">GitHub Release</a> 下载。</p>
<p>下载完毕后，用 PowerShell 运行文件夹下的 <code>Install.ps1</code> 按照提示操作即可安装成功。<br>
建议设置在中把默认 shell 改成 PowerShell：</p>
<img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308105324042.png" alt="image-20200308105324042" style="zoom:67%;">
<h3 id="修改字体">修改字体</h3>
<p>如果前面已经在 Powershell 安装了 oh-my-zsh，此时的 Fluent Terminal 下的Powershell 依然是存在“乱码”的现象。<br>
这时候需要下载并安装支持 oh-my-zsh 对应主题的字体，比如 powerline 的字体库： <a href="https://github.com/powerline%E3%80%82%EF%BC%88%E5%85%B6%E5%AE%9E%E6%88%91%E7%94%A8%E7%9A%84%E4%B8%8D%E6%98%AF" target="_blank" rel="noopener">https://github.com/powerline。（其实我用的不是</a> powerline, hhh）<br>
安装后再在 Fluent Terminal 的设置中更改字体就大工告成了！</p>
<img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308105823820.png" alt="image-20200308105823820" style="zoom:50%;">
<img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308110523327.png" alt="image-20200308110523327" style="zoom:80%;">
<h3 id="VSCode-终端美化">VSCode 终端美化</h3>
<p>在之前的基础上，只需要修改 VSCode 的终端字体即可；<br>
可以编辑 <code>setting.json</code> ，也可以在设置中查找。</p>
<img src="file:///C:/Users/wcb53/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" style="zoom:80%;">
<p>效果图：<br>
<img src="/2020/03/08/%E3%80%90%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E3%80%91%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E8%B8%A9%E5%9D%91/image-20200308111027390.png" alt="image-20200308111027390"></p>
<hr>
<h1>美学感悟</h1>
<blockquote>
<p>挂了美学的旗子，估计是膨胀了。 😢</p>
</blockquote>
<p>折腾一番还是蛮消耗时间的，但是克服不了变美的诱惑 😄。</p>
<blockquote>
<p>有时候会问，人的品味高是不是有时候会降低人的生活质量？</p>
</blockquote>
<p>百姓的音乐在高雅之士的耳朵里变成了“呕哑嘲哳”；<br>
普通餐馆的食物在美食家面前变成“糟蹋食物”，<br>
专业设计师会感觉市面上的东西各种变扭等等。</p>
<blockquote>
<p>扰乱人们的不是客观事物，而是人们对客观事物的见解。<br>
​	—— 爱比克泰德<br>
“超常的感觉能力会引致情绪失衡、周期性的超乎寻常的愉快或者挥之不去的忧愁。”<br>
—— 叔本华</p>
</blockquote>
<p>笔者感觉，叔本华描述了那些艺术天才的忧郁气质，像极了《名人传》里对米开朗基罗的描述：“他被他这个天才左右了一生，他一生根本就没法从他这个天才里头自拔出来，所以他的生活某种程度像个苦行僧一样的，又是个工作狂。可是他的一切，他活着就是为了这个优势，为了他的天才而生的，他这一辈子就只能在这个范畴里头这么去干。”</p>
<p>但是除去那些被自己的天才左右了一生的天才，现实生活不是也有很多很多很释然的杰出艺术家吗？就像《名人传》的米开朗琪罗传的那句名言：“世界上只有一种英雄主义,就是看清生活的真相之后依然热爱生活。”</p>
<p>一个思考角度，我们完全可以驾驭我们的感觉能力，获得释然，开放“对客观事物的间接”，能够同等欣赏“阳春白雪”和“下里巴人”，获得生命的快感。</p>
<p>另一种思考的角度，艺术家的忧郁气质，对于细节的感知、把控与纠结的完美主义，恰恰成就了艺术家，成为无可争辩的竞争力。</p>
<blockquote>
<p>美，是一种感知。<br>
潜藏在每个人生命中，<br>
当它被挖掘，被激发，<br>
便会变成一种使人安定的力量。<br>
它不仅能带来感官上的触动，<br>
也是历练生命、丰沛情感、释放思想的源泉。<br>
—— 蒋勋</p>
</blockquote>
<p>在物质匮乏的年代，对食物挑剔的人甚至没办法生存。但是现代社会已经逐步脱离物质的快发，转向追求生命的更高体验。<br>
就像蒋勋先生所言，美是历练生命、丰沛情感、释放思想的源泉。我想，不去审美而去猎奇，真是辜负了造化的恩宠。</p>
<hr>
<h1>参考文章</h1>
<ol>
<li><a href="https://walterlv.github.io/post/customize-fonts-of-command-window.html#%E6%8E%A8%E8%8D%90%E5%8F%AF%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93" target="_blank" rel="noopener">自定义 Windows PowerShell 和 cmd 的字体</a></li>
<li><a href="https://blog.csdn.net/WPwalter/article/details/78937346" target="_blank" rel="noopener">将美化进行到底，把 PowerShell 做成 oh-my-zsh 的样子</a></li>
<li><a href="http://tieba.baidu.com/p/6133164423?red_tag=o2118687620" target="_blank" rel="noopener">oh-my-zsh的图标无法正常显示</a></li>
<li><a href="https://sspai.com/post/52868" target="_blank" rel="noopener">告别 Windows 终端的难看难用，从改造 PowerShell 的外观开始</a></li>
<li><a href="https://www.jianshu.com/p/ae7f7b4d7a0e" target="_blank" rel="noopener">解决vscode terminal powerline字体乱码</a></li>
</ol>
<blockquote>
<p>此外，还有感谢 <code>wj</code> 小姐姐 👸 提供给庸人笔者的一些灵感~</p>
</blockquote>
]]></content>
      <categories>
        <category>Life</category>
        <category>Beauty</category>
      </categories>
      <tags>
        <tag>Powershell</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>libnum-error</title>
    <url>/2020/02/05/libnum-error/</url>
    <content><![CDATA[<p>由于之前清理空间的时候不慎将 WSL 的配置文件也误删掉了，所以慌忙还原 WSL 当初的配置，对于一些 Python 库的安装大多用 <code>pip</code> 的命令，直接安装，通过 <code>import ...</code> 的方式做一个简单的检查。但是前段时间在使用 <code>libnum</code> 的时候遇到了 <code>AttributeError: 'str' object has no attribute 'hex'</code> 的报错。</p>
<p>网络上并没有这么针对性的博客来排除这个 <code>AttributeError</code>，也几乎没有讲过用 <code>pip</code> 命令其实也可以安装 <code>libnum</code>。</p>
<p>所以这篇文章就讲解 <code>libnum</code> 两种不同的安装方法，以及为什么会出现和如何解决 <code>libnum</code> 下的 <code>AttributeError</code></p>
<a id="more"></a>
<h1>python libnum库安装使用方法</h1>
<p>方法1：<br>
在 Python 2.7 的环境下安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hellman/libnum</span><br><span class="line"><span class="built_in">cd</span> libnum</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>方法2：<br>
在 Python 3 环境下安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install libnum</span><br></pre></td></tr></table></figure>
<h1>Python2 for libnum</h1>
<p>这里做下解释，如果搜索 “ python libnum 库安装 ”的文章，一般都只会告诉你第一种方法。</p>
<p>这是因为在很长一段时间，<code>libnum</code> 都只支持 Python2，在它的开源库中我们也可以看到：“Requirements: python2.7”</p>
<img src="/2020/02/05/libnum-error/libnum-error.png" width="500">
<p>甚至在 2018 年 12 月还有人 issue 是否支持 Python3：</p>
<img src="/2020/02/05/libnum-error/libum2-3.png" width="500">
<p>很多写 <code>libnum</code> 安装教程的博客也多半是在 2018 年12月前写的。</p>
<h1>Python3 for libnum</h1>
<p>然而！！！在 2019 年 3 月的时候有人回复了这个 issue，已经实现支持 Python3 的libnum。</p>
<img src="/2020/02/05/libnum-error/libnum3.png" width="500">
<p>其地址是：<a href="https://github.com/JafarAkhondali/python3-libnum" target="_blank" rel="noopener">https://github.com/JafarAkhondali/python3-libnum</a></p>
<p>同时我们可以查到在 <code>https://pypi.org/</code> 中查到 <a href="http://project/libnum/" target="_blank" rel="noopener"><code>libnum 1.6.0</code></a></p>
<img src="/2020/02/05/libnum-error/PyPI.png" width="500">
<p>此时可以用 <code>pip install libnum</code> 的方式安装 <code>libnum</code>，但需要注意的是，这里的 <code>pip install libnum</code> 对应的是 只支持 Python3 的 <code>libnum</code>。</p>
<h1>AttributeError: ‘str’ object has no attribute ‘hex’</h1>
<h2 id="报错原因分析">报错原因分析</h2>
<p>出现这个错误的原因是 python3 中只有 unicode str，所以把 decode 方法去掉了，所以 “str’ object has no attribute 'hex”。</p>
<blockquote>
<p>比较抱歉，没有截图，只是文字描述。</p>
</blockquote>
<p>我们仔细看报错的信息，稍作分析就发现，运行过程中是遇到 <code>encode('hex')</code> 之类的方法的时候报错的。说明错误是用 Python3 的解释器去解释 Python2 的代码 或者其他等价的情况发生的。</p>
<p>很可能是因为我 当初+后来 同时使用 <code>pip install libnum</code> 和 <code>python setup.py install</code> 的方法安装库，所以导致解释器解释代码的时候产生冲突。</p>
<h2 id="问题解决">问题解决</h2>
<p>笔者并不精通 Python2 和 Python3 的兼容问题。<br>
只是单纯在 Python2 下使用这些库（毕竟 Python3 的环境是部署在 Windows下的，WSL 只是由于特殊情况也安装了Python3），所以采用 <code>pip uninstall libnum</code> 的方法卸载了支持 Python3 的<code>libnum</code>库。</p>
<p>之后代码解释正常，也得到了 flag, hhh。</p>
<img src="/2020/02/05/libnum-error/flag.png" width="300">]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年终总结 - 对自己负责</title>
    <url>/2020/01/25/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<img src="/2020/01/25/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/man-3777108.jpg" width="800">
<blockquote>
<p>总是有人以上帝视角对你说，“你现在所经历的，在未来看来根本不算什么。”<br>
我不喜欢这句话。这一句话本身没有错误，但是却有所偏袒。它偏袒结果。<br>
我想补充的是：“如果没有现在正在经历的痛苦，未来的痛苦会更加难以承担。”</p>
<p>己亥年收获很多快乐与幸福之余，也经历了前所未有的失落、失望、绝望。</p>
<p>庚子年希望能够承担起更多曾经难以想象的苦楚，逐步揭穿生活巨大的隐喻，抬起头，在克莱斯勒《爱的忧伤》的尽头，迎来《爱的欢乐》。</p>
</blockquote>
<a id="more"></a>
<h1>时间维度</h1>
<h2 id="对过去负责">对过去负责</h2>
<h3 id="历史观">历史观</h3>
<p>我以前不是特别喜欢历史，说心底话（而不是以前答卷上写的漂亮话），总感觉它们离自己太远，没有特别大的意义，顶多是多了一些故事用以“以史为鉴”，多了一些风云人物用以“勉励后生”。</p>
<p>现在想想，那时候的我的历史观其实非常平面化，那个时候理解的历史其实可以切成现在进行时的另一个平行空间。他们有他们的风云人物，他们有他们精彩的故事。是的，我的潜意识断开了他们和现在之间的联系。</p>
<p>现代社会不是凭空而来的，滚滚而来的历史，它们的价值和意义是难以估量的。</p>
<p>当然我这样思维的错误也没有那么彻底，中国的近现代史和现代的联系我是能够深刻体悟到的。中国的近代史是我的高中同桌 yyy 最不喜欢这一段屈辱的历史。虽然我也谈不上喜欢，但是它们却是我自己能感受到历史感的一个重要部分，也是能激起我的心灵震荡的一个重要部分。</p>
<h3 id="个体历史观">个体历史观</h3>
<p>历史裹挟着滚滚红尘浩浩荡荡地前行，如果一个国家和民族企图切断和历史的联系，把他们当做一个和自己毫无关联的平行时空，那是一件蛮恐怖的事情。</p>
<p>人也是带着各种各样的羁绊和时光在自己人生留下的印记不断前行，如果否定过去，不能痛彻心扉地反思，也同样恐怖。</p>
<p>虽然一个个体相比于历史长河，不过沧海一粟，但对于我这样很关注“自我”的凡夫俗子，十分重视这样的“个体历史观”。（可以理解为人生观的一部分）</p>
<h3 id="2019-我的爱情史">2019 我的爱情史</h3>
<blockquote>
<p>人总是踏入同一条河流。<br>
——吴人问津<br>
我们在自己所有的细节中都无意识地将自己的曾经错误“贯彻”到底。<br>
和自己的周边所有人的交流方式、在人群中的表现等等都总是犯着本质上完全相同的错误。<br>
以不同的表现形式，在不同的时期，尽是这般绝望地相似。</p>
<p>所以我们需要一日复一日地戳痛身上、心上的曾经的伤疤，一日复一日地自我沉思，一日复一日地坚定信念和自我革命。</p>
<p>人生没有存档服务，没有入栈保存的结点，没有版本控制器，没有快照。<br>
有的只是掩面痛哭和一往直前。</p>
<p>以上。</p>
</blockquote>
<h4 id="爱情·掩面痛哭">爱情·掩面痛哭</h4>
<p>悲伤抑郁的时候，我感觉自己是一个蛮负责的人，对自己的情绪负责的人。<br>
今年和自己喜欢的女生分开了。转身走去的那一刻我就开始哭泣，回到在简陋的宾馆里继续痛哭。我没有试图用其他方式转移注意力，我不想逃避这样喜欢一个人的心情，不想逃避离这样的痛苦，不想忘记这一份“相互喜欢的人不一定能够在一起”痛彻心扉的领悟，也不想忘掉这一场奋不顾身的初恋。</p>
<p>哭，可能需要安慰，更需要面对。<br>
情绪和痛觉一样都在给我们传递很重要的信息，来无踪去无影，错过就不再。</p>
<h4 id="爱情·一往直前">爱情·一往直前</h4>
<p>之后的几天，我更是噙着泪水，把我们在一起时所有的经历都回顾了一遍，所有的共享、所有的聊天记录、所有的照片。游览完所有的照片之后，都打包上传到云端，删除了本地文件。<br>
之后很长的时间都在慢慢消除她在我生活中留下的痕迹。</p>
<p>当了一回专职的心灵解剖医生，解剖分析自我。<br>
我慢慢在这一段亲密关系中剖析出自己深层的人格特征，也正是这些，葬送了自己的爱情。</p>
<p>感谢那时候把分手的痛苦贯彻到底的自己，不仅仅停留在那个时候的观念，也想尽办法建立方法论去克服自己在亲密关系中暴露的问题。<br>
然后践行 “人生，有的只是掩面痛苦和一往直前” 的感悟。</p>
<h4 id="爱情·领悟">爱情·领悟</h4>
<p>像周国平说的那样，没有深爱过的人和世界是没有建立联系的。我现在更能理解这一点。我的亲人（尤其是我姐~）对我的爱我现在更能体会。每次寄礼物，仔细挑选、包装、传递情感，整个流程包含的，以前的我绝对没有现在能感受到的这么多。</p>
<p>之前还看了一篇心理学的文章，讲的是恋爱的意义。“自己一个人明明过得很好，为什么还要谈恋爱？”这是很多人的想法。亲密关系对于人来说，首先的确是可以满足一系列片面的需求。比如打发时间的需求、互相陪伴和支持的需求、性的需求、甚至是经济的需求等。但我们从亲密关系中能够获得的东西，其实还远比这些更多。正是因为亲密关系的这种机制，它也成为了我们人格疗愈的一种最为重要的契机。恋爱不是简单的相处，真的是一种自我寻找和相互寻找。</p>
<p>分析分手原因不是为了挽回，虽然这只是无意间慢慢理解的。<br>
虽然大脑会习惯性会“理想化”过去，但我早已抵抗住这种错觉，我知道我们如果重新再来，我还没成长到在亲密关系中自信到她能满意的程度，她也很可能没有办法兑现时常牵挂及时回复我的一纸承诺。</p>
<p>过去的幻象再美，死灰复燃的爱情都没有意义了，没有痛彻心扉的每日自我革命，重来也会掉进一样的漩涡。</p>
<h3 id="2019-我的家族继承史">2019 我的家族继承史</h3>
<blockquote>
<p>那些由不安惶恐凝聚而成的血泪，<br>
就轻易被现实揉进深深的夜梦，<br>
写进逃不过的宿命，<br>
摁进扭曲的自我。</p>
</blockquote>
<h4 id="血脉·继承">血脉·继承</h4>
<p>关于这一点的感悟其实在高三成年人礼的时候就写下了，那个时候写得很深刻，这里也没想着再写一遍。<br>
过去的我觉得血缘联系是蛮荒诞而狭隘的，自己不想囿于自己的血缘，于是企图摆脱。当我觉得自己已经成功做到从这种束缚中挣脱出来之后，却一次又一次地遇到打击、失控和现实的冲撞，我逐渐发现我深层次的种种特征都和我父亲一模一样。<br>
这里用这样简练的语言概括当然难以说服人，也可能被认为是荒谬的；我也知道即使再次详细地描述我所经历的所有那些冲击我世界观的经历，很多人未必能够理解。真的，经历比任何说理都更加有力。</p>
<p>与其去理解，不如去感受。</p>
<h4 id="血脉·超越">血脉·超越</h4>
<p>这一年我对于它的理解和体悟进一步加深了，也和一个人讨论过。但是讨论的对象正是那种无法理解我的人。<br>
努力就能有可观的回报，不用竭尽全力和历尽绝望就抵达自己想要的地方，这样的人，我知道可能没有机会体会到和真正理解我的痛苦和底层的卑微。</p>
<p>但是，恰恰也给了我启发，在她的鼓励下，也在意识上觉得能够改变那些血脉中继承的，刻骨铭心之物。<br>
也许很艰难，也许穷尽毕生也未必有大的改变，但是即便如此、即便如此也不能就此放弃抵抗。</p>
<p>还是非常非常感谢那个她。</p>
<h3 id="2019-回忆孤独的过去">2019 回忆孤独的过去</h3>
<p>现在回想，依然非常非常怀念高中的那三年，那是非常纯粹的三年。<br>
每天和很纯粹的知识、题目搏斗，每天和很纯粹的自己、他人搏斗。</p>
<p>大学时的压力确实没有高中时的压力大，高中的竞争氛围非常浓厚，每次模拟考的排名、明细、试题分析、互批、对比、竞赛，让人长期处于高压的状态。<br>
我已经难以想象当时自己的压力，翻看过去的日记，真的已经难以还原当时的情景，我不知道在怎样高压下的我才能写下那样压抑、激情甚至有些燃烧的文字。</p>
<p>那是过去的我的努力。每次翻看日记或多或少有些愧疚感。人应该变得更加优秀、更加卓越。真正的卓越是优于过去的自己。一旦选错参考系，就容易妄自尊大和妄自菲薄。<br>
要对过去的自己负责，对那个无比纯粹的自我负责，对那个在内心呼喊、咆哮的自己负责，对那个写着无比孤独文字的自我负责，对那个在操场狂奔到泪流满面的自己负责，对那个疲惫到难以入睡需要从黑暗中摸索出一瓶温和的牛奶、咕噜咕噜下肚才嫩缓和的自己负责。<br>
这样才不负过去。</p>
<h3 id="个体历史-史官">个体历史-史官</h3>
<p>历史有专门的史官记载，但个人历史却少有人记录。可能只有作家、名人以及少数有写日记习惯的人才会记录自己的个体历史。<br>
以史为鉴是对历史负责的一种方式，而以史为鉴的前提是：“有史”。</p>
<p>个人要对自己负责，就要能保留住自己的个体历史。人一时的记忆给了人一种错觉，即：我以后会记得此时此刻。<br>
遗憾的是，人的记忆没有那么持久，并且很受主观因素的影响，无法作为保留个人的个体历史的方式。很多重要的经历由于种种原因可能会淡忘，即便记住了，记忆本身也不能保留住它的重要的细节。“好了伤疤忘了痛”就是一种很典型又非常普遍的事后发现忘记当初教训的体现。</p>
<p>对过去负责是方式是，用文字或者其他方式记录下过去，无论它是带给你欢乐和幸福的回忆还是痛彻心扉的痛苦。<br>
可能没有这些记录，一年又一年地过去，我们也便一年又一年地淡忘自己的快乐，一年又一年地忘记自己的伤疤带来的苦痛，然后一年又一年地没有成长。</p>
<p>我是一个很贪心的人，希望此时此刻的自己是由过去无数个自己的完美迭代：每个加入迭代的版本都是那个最优的部分，剔除糟糕的部分，不将同样的错误再故伎重演。</p>
<p>然后将痛楚转化成防止故伎重演的方法论，一直指导着自己前行。</p>
<h2 id="对现在负责">对现在负责</h2>
<blockquote>
<p>我可以从很多人身上看到自己的影子，但是仅凭这些依然无法拼凑出一个完整的自己。</p>
</blockquote>
<p>总是有人以上帝视角对你说，你现在所经历的，在未来看来根本不算什么。<br>
这一句话本身没有错误，但是却有所偏袒。它偏袒结果。有时显得冷漠。<br>
作为正在经历痛苦的人，我会补充另一个本身没有错误的话以完整这句话：“但是没有现在正在经历的痛苦，未来的痛苦会更加难以承担。”</p>
<p>不得不承认，此时此刻的自己正处于一种迷茫和孤独之中。<br>
常常感觉自己是套着一透明的膜，然后混进人群。</p>
<p>我总会想起太宰治说过的一句话：“活着，那是多么忍辱负重、奄奄一息的伟大事业。”<br>
虽然我没有完整地读过他的著作，但心想他口中的“活着”绝非是生理上那种简单地“活着”。<br>
要怎么对现在的真实的自己负责，怎样不敷衍、不自自我欺骗、不迎合随流，真的真的是一件“多么忍辱负重、奄奄一息的伟大事业。”</p>
<p>这样一种逐渐脱离群体，走向自我的道路，似乎是真正成人的必经之路。<br>
我慢慢接受这一种孤独，群体中我的确是异类。<br>
但我知道，那些人之间的沟通不是心有灵犀，是平庸。<br>
但是我看到很多也是异类的人却活得很光彩，活得很自在。<br>
我想，只要继续努力、贯彻自我，对现在负责，不忘初心，<br>
既然这个世界宣称是多元而包容的，总有一天，我也会找到适合的舞台。</p>
<p>那不是心有灵犀，那是平庸。</p>
<h2 id="对未来负责">对未来负责</h2>
<blockquote>
<p>我们就是这么无可救药的生物吧，迁就着自己的幻想妄想理想梦想，混进人群，低声不语。</p>
</blockquote>
<p>人在回顾过去的时候，会这样想：如果当时能够如何如何，现在就不会是目前这不堪的境况。<br>
但是殊不知，如果现在能够做出改变，就能改变未来。</p>
<h3 id="对身体负责">对身体负责</h3>
<p>我们活得太久了，忘了自己终将会死的事实。</p>
<p>这一年我的作息出现了很多的变化。</p>
<p>以往的我，哪怕是假期也遵循着在学校的作息，早睡早起，定时午睡。哪怕在忙，也不会晚过十二点。</p>
<p>大一下的后期，为了完成数据结构的实验报告，为了完成自拟的大学物理编程题，连续几天十二点半睡觉，六点半起来。虽然现在回忆起来已经感觉不算什么了，但是整栋楼都是断电的，室友都已经上了床，自已依然在下面噼里啪啦地敲着键盘，是完全新奇的体验。</p>
<p>在新加坡国立大学做项目期间，更是讨论到三点钟才散会休息。</p>
<p>大二上开始变态。最开始是每天睡眠六个小时，基本是六点半起床离开寝室，晚上十一点回寝室，十二点半睡觉。<br>
遇到什么特殊的情况的时候会特别加上“加班”的时间。一次加班加一个半小时，也就是两点钟睡觉，加两次班就是三点半睡觉，一天睡三个小时。印象中有四天的平均睡眠是五个小时……<br>
还在实验室一个人趴/躺在桌上陪着服务器的噪声睡了一个晚上</p>
<p>让我感觉离死亡十分接近的那一刻是一次分享会上，hrdg 告诉我们他们 ICPC 校队里有人猝死。<br>
生命是一切的前提，死亡就是失去和这个世界交互的权力。<br>
那么一件事情就发生在离自己那么近的地方，顿时毛骨悚然。</p>
<p>我一直有一种觉得自己身体还不错的错觉。</p>
<p>直到出现一些小小的迹象，再到体能测试， 1500m 虽然达标优秀，但是速率是按照之前的速率跑的，跑得居然有点想要呕吐，前所未有。</p>
<p>期末考前大家疯狂熬夜，</p>
<p>疯狂复习。但是我……在第一门考试之前就被系统抛出了异常，某个早上，自己的左下腹部疼痛，根本没有办法走路，是在去了洗手间回来的路上发作的，突发抽搐疼痛，条件反射地猛地蹲了下来。之后发现站起来就会感到疼痛，所以在走廊道上，蜷曲着身子，缓缓地向工作室的方向挪动。有时候挪动都会感到疼痛。那条 50 米的走廊，花费了 30 分钟的时间才走完。事情还没有结束，那天下午突然流鼻血，一个小时之后才勉强止住。</p>
<p>在第一门考试还有两天的时候，我突然生病了，早上起来以为是没有睡醒，晕乎乎的。洗完脸回来发现是真的晕。不妙，多半是感冒发烧了。然后躺到床上，想着睡一会就恢复了。显然我欠下的债没有那么少，它没有罢休。醒来之后头更加晕了。寝室这个时候已经没有人了，大家纷纷跑去图书馆复习了，一个没有复习完、甚至感觉遥遥无期的被病魔追债的孩子被缠身，卧病在床。</p>
<p>后来撑着去了医院，吃了药，暂时缓和了一些。</p>
<p>之后复习的关键节点完全没有之前熬夜的冲劲，养生学习法。</p>
<blockquote>
<p>想起李开复的《向死而生：我修的死亡学分》，想起《叛逆的鲁路修》中不死的 C.C，笨拙地说一句，我们活得太久，以致于我们淡忘了我们终将死亡的事实。</p>
</blockquote>
<h3 id="对理想负责">对理想负责</h3>
<p>2019 遇到了很多精彩的人，遇到了不仅有梦而且敢于做梦的人，遇到了综合实力很强的人，遇到了敬畏神明的人，遇到了每次聊天都能给我带来惊喜的人，遇到了很执着于自己感兴趣的事情的人，遇到了让我怀疑自己价值、感觉自己的生态位被取代的人。</p>
<p>我对自己想要专注的方向愈发了解，愈发清晰，理想也一步步实体化。一部分焦虑因为真正了解事实和原理之后而消散，一部分焦虑因为认识了真正的现实和黑暗之后而猛增。</p>
<p>对理想负责，就要去理解自己的理想是什么，是否有价值。</p>
<p>虽然在思修之旅之后更加坚定，但在一个根本问题上，我却摇摆不定。</p>
<blockquote>
<p>主人：那咱们往哪走啊？<br>
雅克：往前走。<br>
主人：哪是前啊？<br>
雅克：我对您透露一个大秘密，这是人类最古老的玩笑。往哪走，都是往前走。<br>
——《雅克和他的主人》(米兰·昆德拉)</p>
</blockquote>
<p>我不知道，那些乐观主义者是真的将我们带进更加美好的世界，还是进一步步入泥沼？我们前进的方向，是否会将我们自己灭亡？</p>
<p>如果说人类的进化史是一个延迟满足感的能力逐渐提升的过程，现代社会不进反退，人类终将成为娱乐至死的生物。</p>
<ol>
<li>娱乐节目中自带的解读和标识，越是受欢迎的节目，就越是不需要脑子就能产生愉悦感。</li>
<li>UI\UX 每一个设计都是慢慢的反馈和舒适感</li>
<li>QQ 空间、微信朋友圈、微博等社交平台成为情绪的发泄点，人们慢慢不会驾驭自己的情绪，不能静静地洞察更深层次的东西</li>
<li>碎片化阅读、交互式编程、视频弹幕这些奖励机制折射出来的互联网前进的方向就是“大家就是想着怎么样让你现在就爽”</li>
<li>老师也异常的浮躁<br>
综合课程设计做了那么多的可视化，我以为再怎么最初不了解 SDN 的人看了我们的 PPT 和听了我们的讲解之后一定会立刻理解，结果他们头都不抬，那一刻起，我对那些老师感到失望透了。</li>
</ol>
<p>最吸引人的未必是最有价值的。</p>
]]></content>
      <categories>
        <category>Life</category>
        <category>Reflection</category>
      </categories>
      <tags>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode Remote-SSH Kali 配置</title>
    <url>/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<img src="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/architecture-ssh.png" width="700">
<h1>前言</h1>
<p>SSH 是我们经常用的一种协议，而 VSCode 的拓展 Remote-SSH 确实给力，允许在远程连接，在本地的终端进行编程。对我而言，就不需要在虚拟机 Ubuntu 里面安装 IDE，或者每次用共享文件夹编程完后跑到虚拟机中再跑程序。可以直接在自己的 Windows 下的 VSCode 进行编程。</p>
<p>关于这方面的博客大多只有陈列一堆的命令而不加解释，读者照抄命令，有时候可以成功，有时候却不能，有时候抄命令抄一半就忘了抄到哪里。</p>
<a id="more"></a>
<p>最糟糕的是不能举一反三，比如现在似乎没有用 Remote-SSH 连接 kali 的文章。这也正是此文章的目的所在之一。<br>
此文章最重要的目的在于将整个过程命令的含义和排错命令进行阐述。</p>
<h1>SSH 需要注意的几个点</h1>
<h2 id="SSH-命令">SSH 命令</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 22 username@ipaddress</span><br></pre></td></tr></table></figure>
<h3 id="端口">端口</h3>
<p>在命令中已经声明端口是22 （<code>-p 22</code>），很多时候可以省略这个参数，因为 <code>ssh</code> 命令默认的端口就是 22。</p>
<p>端口 22 有时候是没有打开的，在 Linux 和 Windows 系统中都是用 <code>netstat -an</code> 来查看所有开放的端口。</p>
<p>在 Linux 下可以用 <code>netstat -an | grep :22</code> 来查看端口 22 是否开放；<br>
<img src="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/Ubuntu_netstart_22.png" width="500"></p>
<p>在 Windows 下可以用 <code>netstat -an | findstr &quot;:22&quot;</code> 来查看端口 22 是否开放。<br>
<img src="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/Windows_netstart_22.png" width="500"></p>
<h3 id="连接成功">连接成功</h3>
<p>连接之后查看信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@hostname :~$ <span class="built_in">echo</span> <span class="variable">$SSH_CLIENT</span></span><br><span class="line">xxx.xxx.xxx.xxx portxx 22</span><br><span class="line">user@hostname :~$ <span class="built_in">echo</span> <span class="variable">$SSH_CONNECTION</span></span><br><span class="line">xxx.xxx.xxx.xxx portxx xxx.xxx.xxx.xxx portxx</span><br></pre></td></tr></table></figure>
<h3 id="主机名与用户">主机名与用户</h3>
<p>一种可能导致连接不成功的原因是把主机名和用户名搞混淆了。<br>
这样会错连接一个可能存在也或者不存在的用户。</p>
<p>查看主机的命令是 <code>hostname</code> ，查看用户的命令是 <code>whoami</code>。</p>
<p>其实也可以发现在 Linux 的终端中，每个命令的头部是 <code>username@hostname</code> ；<br>
而 Windows 的终端中命令的头部只有目录信息。</p>
<h1>VSCode Remote-SSH — kali</h1>
<h2 id="VSCode-Remote-SSH">VSCode Remote-SSH</h2>
<p>这个拓展是非常易用的，只需要启动 <code>Remote-SSH</code>后点击 <code>Remote-SSH:Connect to Host...</code>，输入 ip 和密码就可以 SSH 连接到远程机器。</p>
<h2 id="kali">kali</h2>
<h3 id="1-Permission-denied-please-try-again">1.Permission denied, please try again.</h3>
<p>如果用同样的方式去连接 kali 的话，会遇到的第一个情况是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Permission denied, please try again.</span><br></pre></td></tr></table></figure>
<p>原因在于用上述的方式默认连接的是 kali 的普通用户，但是 kali 是默认是特权用户 root，所以输入的账户和密码是不对应的。</p>
<p>解决的方法是：</p>
<p>启动 <code>Remote-SSH</code>后点击 <code>Remote-SSH:Connect to Host...</code>，再点击 <code>Add New SSH Host...</code>，根据提示输入<br>
<code>ssh root@xxx.xxx.xxx.xxx</code>，此时再连接，输入的密码就匹配上了。</p>
<h3 id="2-ssh-connect-to-host-xxx-xxx-xx-xx-port-22-Connection-refused">2.ssh:connect to host xxx.xxx.xx.xx port 22: Connection refused</h3>
<p>虽然密码正确，但是依然连接不上。<br>
现在再去查“kali使用ssh进行登录”，就很容易明白为什么 kali 使用 ssh 登录需要改那里改这里了。</p>
<p>这也是 kali 是默认是特权用户 root 导致的。平时我们用 SSH 连接的是普通的用户，连接特权用户需要更改 SSH 的配置文件。</p>
<h3 id="修改-ssh-配置文件">修改 ssh 配置文件</h3>
<p>在 kali 的终端下：<br>
需要修改的 ssh 的配置文件有 /etc/ssh 下的 ssh_config 和 ssh文件。</p>
<h4 id="修改-ssh-config-文件">修改 ssh_config 文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/ssh</span><br><span class="line">vim ssh_config</span><br></pre></td></tr></table></figure>
<p>修改一个地方：<br>
<img src="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/PasswordAuthentication.png" width="300"><br>
保存修改，退出 vim 编辑器</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure>
<h4 id="修改-sshd-config-文件">修改 sshd_config 文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim sshd_config</span><br></pre></td></tr></table></figure>
<p>修改两处地方：<br>
<img src="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/PermitRootLogin.png" width="300"></p>
<img src="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/PasswordAuthentication_d.png" width="600">
<p>修改的含义，根据其中文意义和文章之前的解说应该非常容易理解。<br>
保存修改，退出 vim 编辑器</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure>
<p>重启ssh服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh strat</span><br></pre></td></tr></table></figure>
<p>有时候重启一下才会生效（不知道为什么）。</p>
<h3 id="连接">连接</h3>
<p>再一次用 VSCode 的 Remote-SSH 连接，就能成功连接 kali 了。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>SSH</tag>
        <tag>VSCode</tag>
        <tag>Remote-SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>SDN-DDoS Question & Consult</title>
    <url>/2019/12/08/SDN-DDoS/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b30ac1cb228034968461e17cabfeb285dc6c695eb6cc7adcc0d7260fcfb95030">c54ef91cce081c6f61e5353cd8bb7033a3a4a4b1fe8abe1b1454f387adbd37348102c6722f4de38abc5e5e7d11e33fb607922e0136851a98202d2c2b9a9b8a4ae5c7908e0d2ec37060e38f7f1217d5781d9f66f930a254506f89c0f90a17be7355fcf26b1e8c3609d466f7df9a2969c9d58a0c3380e6d3e8f87b9ab586c999d4880bd42265233c6cd8b2a026ab3781e30f807c895d127e9b393a71022ac14285953ef63e9348dd40f36d88037e6c2c1b4862924b06f35195f1b51a3333d6e1c318404e0f6a5cd03135e6670161381323c586d2bc95f98afab5350fcaac50ba1d28016418ec73854a93c9a7b43efad3fa49f27aef618045463187c6cfa6e5fbd216b104cccfbc70be79d441c6a30b686c77d4acc3277520686733121015b7a7d429c55004a668dde07877d6676594439fc0feaa056b824d3e9df8708d9e598c8171b72a7d583731487787f192d3e2813be84291edee4e40b939a3deca89df3e6c43e43467d11750e6be778426bd899efce463b6660acba0f23f4567ef5640f3e41acdf17b11fdd72690a36153955ddc7369dc9b119186315ade21e07c9a63dc905e02247821f94e7d394460c3ec13ccfe1a191d13bc72925bc810dccbe3ee6da4a47616127a1b76d0b9ac9893203a47262424cc8a505a796edf640611141d82f22208e6533c28b7bef743ab0b33d93ed6f1b250189961623f73b1658c267c945bf516c339d4fb6576e6da22bf5a66cf4f1b2d11def69cd85376ccef41b6c34b2a27f493f4ad96a3c181c2fb214def70847082241e7b29dd146b88a262388ffa8199092053ecabab51abe6a2d2cfdc893e6221970f4bad1717d1dae9350ea8f001ee90196264136e76dcbe5213d0d0727ddf47407381f0a4f2c1b52650802db59ad035cb3e9648f8350ff4a87bb797f7909ef4a272fcdd243e35f331a0850764ae63352a2be25143468e15781804f84895824bb37858f4a5d14dc8a98fbb3b2687389e64d8ccefc53d2f84e840392c317bee20f4a5a8f5aac2ed65f0d7acf9ffce370ed55c45739de2e608ef72fbbf64d0a7048fabb59b52441c5d2383e8caf60d18b1134a54657c6592f681743f71d0115e6e00c620358065f59e3b61ebcd5823922239522ac56793eb15fa38c35c5fded0eef718a786372636fd57dbe20f6ae88696da0d8f49dc91cbfe65f98c367ede1d5b3c3e6b5b9253a39666c2aa1a141fd286e73760157eb2342ed82833732266de9d25410a6ee48f62ba4306793a5e350cc01a90b11ea7a4e40674d836380cdb4d9a10d455950610f814c77d92d3a03119ca2a249f42b2d47f2fc6d429865477061e0818a19322dfff648f5ed3b0cb33d34439e8302112a2e2e1ca129288ac9b145f79c4259e8fdb80d992f4df477629d21d5812b63969ad8bab195ebb976c3e56cb1ae3c7d398e134c93d327554ac4a9628290ea233b2f905b9c9f4aa2885ac0dee51100074bcc316e796729bf6beece69430b1e6160f6aa145d7f5f110960bb34648f96574161ad5af5ed5aa4bf8cc6fa8fc2980ed6d1dc6aaaf79d2295c80b0bc82dab1bff490026bf57467fafa314b378195ad3b9647793f2208fd1cdf4dcd51d7bde2e6e66cd27b0ff1af3c8536fecf6c97478e1c6d9dfb91f57d70cad375cbe9e62014dba0c77ddfde51a50192f6d9960dc929cbb9b72898a6a03af5039648f5b2d634e38be750f73e9e874cc99025961b0aa2e01f803beecfbb99139f2e154af46f55f6d55d56ccb22a02790ba1f38afb3e5e449dac9217c069bb5976bda7f4eb01ed7374cf079f20b0f712fdd02c71d5d277015a4edbfbc35a254ab18eaf28e11e04f6f22919df14c72d7f0922ad9c32adbb0a74774fca62758f34938a3789e9b50d5e1c49b3d5c45d8c1bba059ddf49965184a19e0fd2ade1887b185ab106fb704c2eef66551d5c31a54af2a8053f60c7a8f43b9c075e3ad5f4b49a54163b3648a509c56a23307a31b5825a8f53beca1a802edff82f6bf5db5600a55183852b2e902ef8176088e0e4bf6c350d5d6b665b6b6132bcacbaeb5ea73179e8d617982a61f950b2f111213965ea7f0c9a371896bd910b9ca69e38582fc2f4d97daab86a82c3da43e46810a38ee846e0f93194d1cef88bca748c44dcc05c2882ef643012a4fffac2c1c87e5a084a7abd90235ef204f612eb7058eb531d4e8485302e3d8c545c5f8d382194d32d999f85c5943a310efedcf24450f9a6276cfac111eaadd496411115e51278518b1cc8d756354074b16547c2fee612e45d5446a2ce89d1a963d2018df3996a3eb2831a6a3d20bd727ac5a7eac9453781d3084f7639ebe6bd6cfe0682d65283d49e5972350178c6c370ec9819d222c62e1bcf0e0c2e57c48052f9a34a0dad4d6c11d2ce4b8db32276503455c60dec21ca51ec59cc67c07b08ec90d016b4687b20575f1141521dbfb15a703caaacf26d911b07961440cc59463b734246dc1b3940c992d5031817c8cba48430392b817600e3f49d6187e1e02aa9daec1290059b2c6a1dbfa077b5054433e2e84a516f86cab562de6b810a5a48a264e1237f5658ca620f72d951f9571c51f0eab6e9154eaf4473554b5dd603342c5c709da69bacda7ae49403913824633ce1fd830a4990006a1e921d1d26f1e5cf47a03efa61bf640bbf8bd71b72f0e50512ce6264b07b7326d3df09b028759d9826fabb35222800dd0d478446ce4a8fd105f2606056aeca7c32a8dcd4d9b2ae1fe436c7e65227f0ab27ad0df4d5722e9a0a997ca248092d5442921f1f79e32dd0540e75331736624cf691c394ee37244c1c51defecfd64614b6d88ab15a585dc56f9877fe9452afe3561810a25aa20faf154c730077f32b3bdbebf1295a3a8e7e1dfd11c88dd048bc832e26fcf883bdc24034f3c1104032c84d77e4631b7ccb84a446bba8d828e9e44cd759740a098965022ed82bf73caf4a3c4d9de551036ad829e425349543294990a21b538608abde83fe1f8151a9200dc7aa1cbf2bbd4206d911b2e65f5b5df092a858f9c2388df2a786db08e7416ab13cd10432b9704de4cc3d2d183f593c470c57e4e23d260dc2f35194e4279537d1ce22666e7f717d85563c2cca19e0b089058c301367b01bd7ed688ca03d8c8956856b9545e1dc02f1c785b3651f3daddf10d1e0ba9641480b15622bde939be92780629836fce24e788204ef15c128fc30940b66e515ca0bc2f8727d14abb69623f7c2d7100374d8505239a98561eabf3c4b7e2dc3245d28ac32494e1dbae83a8be749a75af43d2c8945e1372ef00a183f521ea85405d69be49d1bd280e658912c61455535bc0381d849ebf6ad90907c0bb4bb10816a5177c49bf42baa7a11ed76745e5139575c76b2ff77c82c11f9fac429d5ff1c18fc3281cb2c085172b24d7395cbe420db8ee00768af06f45347f06b5e4295a2afd6659fcae2bc6ec80ab16c22448c8b4b93a8019326843267aac4488c2ada5b9fdab517bfe3d0f915370f41e4400733d6672a27b2f9185efd5bc779fddd4699d4b11d05f774b5c3b9a172cc9d7f718fe03ea9fd455503302b39ce3a5869f9e5bce7085614c9eea21ceeffd0f05f120f05b069dc5bf983e9f77b11ecb6d687dd9aebe9cd9f8bc52c3e5e8f988ab2c24afbf76997cf9167fb6aeddced428d1bf66ebdccc6f79d2a022e9228d7a79885712ef6785a5ef7556527a3be95abf1a99e8d5142c0736d9ca16996896797aaf8d10198527e12fb35608d5e4c747bbd3352e38179960f7b28a5c45f3b539633e76173f69fc0389853f883ec32243a1cf3af8164db63e37761ade068ebe604fe7e49663dd21340f0eeafecfe420727b819211cb8697f4922f99a3db4a348ef7335cea29f13f37cbe334613c84b521420ea2cff12050747cf2a433bb2fbe03c1a22674450689ff4855cbda0e2dd3a435c03dd92cba1b1bf7d09c6bce503ed3ffce6e9ec69ff1bb92e5bedd6c3c3cd41b17e17962a32d52edc9afa817b2042c08c13632433046ea620984e65ea6b4aa2f4fac5d220438600601bfcf2146c1bd941966030267eede66a3ed3d292038c11f6d55c01a8fd38392c3a0fb829df06cc036d6362137671e3be7d2010f720dda9a7f61cd3d4555cb57a3d42d44db6031f847577f9f00e460ee1a74e3f03b15910caa96d8bbbefea71f5656712bbef5a3494717391dcd53dfff3e79e42cac639671b36b13a7178d00fa0c7aabb97631edc63b5383ddb643bdf662363e1e3b3b34d0ae7518582e19824a29a2abbf01b6ae8709e662879a662f3915cd2bd33080d85cdb4514eb3fca8ade71c36341e1704851a2d4d16f6d617b414b5215eed94d40040e0ed89ae7ce8ae59a75ea6706bb095f886ca57a52a9378f0a95d315c08f05072757ec73035f1e3e0ce50153f283aef637fa7a4bea40ddc7f9de2f487136b96a4325252eacea0b58fd9840e77a940145492514c8b5a8247cec716a4503286efbdac7c96a5e1eb2fad07a81b97add0e3bff3f95ba572961978a29362526cc0bc3fd714211503f700fc6d540ae856b13c4c039e2f5e0bc56df067985c0ea4c91a09645433ccfd55d1415bd56bc0ea928b36976d47a0ef0f9ab033fedfe732559f4eb47daf5b269a50d75f7d038371379da0743427f20a3ba519fabf6351f4cf5c0a6b83e077372c1d06e282ad801e2e76cf7130f0eb6ff6a0e12bf9f9d6ddbc2037b815d4aadc0789d30600077090e4f3bc400fafa00d86915e5f98a707504e19bee0c30676f90c5c2c40e2df6ab443f8e3cc0d604eba58da9b0cd3b01fd5e7b1966a8c5b2ecbbbba75eb37cf87743f3a0c268a7340dd7794db21347b2a6e6a96297da261624b24aec1ec38eecb2d233b26fc84b96ce0b3b4f403c6770007af51c0d5517ae602aa27e289bea4f0f592bf6a9587ccd1678623efe4284c1ac1e53f7a3487f3a89196f4466ad206c00ff4f389ad5e690cda1426f9e9035abad284fdc09c351fe61060adf0d4964c33d98f0db4e2466daaf88889b40d3597a5e1a146c2ea8661e1b1289a97766691152e4386a11e4d33e08174a3783b36b11712ed90532de6811ba8610942e184d28cbbdf83a9b15193d6f62ab20147b70cd48e4cf536be08d0ec1e353194b36a198ef3a0d2c2dd96be49140a7cbf4579717674ecf2f58c5fbd3db29a71c54b24ef135760ebf29937353846102d72de55e1c1d3b547c423f36429d1853e288ce99b8491c6d84720e44a7743f09efd5ec84bfe39c00cbfa319804da6b33ae00ec67e8b308b153a4cb996d85f9a523e7b5d2572c3cb180bbd16ebd60cca2991934b008a139228510da564064c7d41522677e660a0e138f01734bcebacbe6cbda89cd443a72c9778ce57d70817a3fc0049451cb3f1d48b2bd0ae175c2cf2e5bb49151a2d5a85f477bad67acd05e27cfc81c125287e0f551b42a3d4c236f200ccaa7b0f76854f0dc0b24536c013f3dc54e2913b8aab875392ad195f26a71fc8007be5b1a7bc9793f286d0e1a53f02dfdb6565245027898dd1e48c67042aabd2f437de5892a739b5c3759f797609589972d12db9f04ba926ed1a1906f88c79382db3696f37e6b7255aa59bdfde5948c1998d6a2c5936198fba77093a6d84cea5cf847474c490f1ed007c706b8bdb803690046086e5e432bb47be122e5395a921d678558e3a40333613964b4ce9884da06cd43e9f7e6ae9eaa3617728a332a5aa4392ca0c02e1691c74</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Web</category>
        <category>SDN</category>
        <category>DDoS</category>
      </categories>
      <tags>
        <tag>DDoS</tag>
      </tags>
  </entry>
  <entry>
    <title>【NUS】基于互联网思维缓解新加坡的排队现象</title>
    <url>/2019/11/18/Joyeat/</url>
    <content><![CDATA[<img src="/2019/11/18/Joyeat/Joyeat-Cover.png" width="800" align="middle">
<h1>问题的提出</h1>
<blockquote>
<p>我们不要一味适应环境，以批判性眼光看世界，这样才能发现问题，才能改变世界</p>
</blockquote>
<h2 id="发现需求">发现需求</h2>
<p>新加坡是世界上排队现象十分严重的国家。且新加坡餐饮业发达，在外用餐的人口比例极高（这源于新加坡快节奏的生活和餐饮的低成本）。<br>
但是让我很震惊的是，在这么一个科技发达、人才辈出、人均收入极高的国家，却没有人来解决这个问题。</p>
<a id="more"></a>
<p>我们对此需求通过调查问卷的形式进行了验证：<br>
<img src="/2019/11/18/Joyeat/调查问卷总述.png" width="400" align="middle"></p>
<p align="center">
图：调查问卷总述
</p>
忽略一些文化因素。排队造成大量的时间浪费，而这些浪费的时间本可以有更灵活的安排，无论是去其他摊点逛逛，还是找个座位舒适的坐下，都能让人们更加“省时、爽”，拓宽了选择的权利，这也正是创新的目标。虽然这样顶天的理想很好，但是脚踏实地地去解决却不是一件容易的事情。
<hr>
<h1>初步的解决方案</h1>
<h2 id="主逻辑">主逻辑</h2>
<p>作为软件学院的学生，我们企图设计用于排队的 app，通过餐馆的线上排队的方式来解决问题。<br>
主逻辑是：借助互联网在 app 上进行选定餐馆\选择排队。</p>
<h2 id="思路一">思路一</h2>
<p>一种思路是：线上和线下会形成两个队伍，这是因为线下排队是根据人在队伍中的位置决定次序，而线上是根据进行排队操作的系统时间，两个排队的次序形式不相容。<br>
这样会导致的最大的问题是：线上和线下排队的不公平：<br>
线上选择排队的时候，同一时间线下已经存在的队列序号可能会滞后于线上排队，造成不公平。	<br>
比如用户 A 在线下排队的时候前面有 10 个人，他选择了线下排队；用户 B 比 用户 A 晚来了十分钟，他选择了线上排队，而假设此时线上排队的人数只有 3 个人，用户 B 在比用户 A 晚到餐馆的情况下依然比用户 A 提早享受到了服务，这对于像用户 A 这样习惯于线下排队的用户显然是不公平的。<br>
如果实体餐馆没有额外负责线上排队的服务的话，显然对线下原有排队的用户是不公平的。并且，不是所有餐馆都具备再额外安排负责线上排队服务的员工的经营能力。</p>
<h2 id="思路二">思路二</h2>
<p>另一种思路是由商家自己根据线下的队伍和线上排队的情况自己进行排序。<br>
传闻美团外卖是这样的模式，需要主观判断。但是他们外卖行业和我们性质不同，差别我们的线上和线下的排队差异会暴露给用户。而采用这个思路的核心是通过商家和主观判断（或者需要我们设计算法）来尽可能减小思路一可能导致的不公平。</p>
<p>但它会导致的另外两个问题是：</p>
<ol>
<li>线上排队用户可能不在现场，不能及时到达，也无法凭借队伍的长度预估时间。<br>
毕竟线上排队提供了不在当场就能进行排队的便利，但带来不能保证及时到达，而耽误商家以及其他用户的资源。</li>
<li>线上排队用户不能及时到达，它的排队号变化的问题。<br>
如果线上排队用户未能及时到达，需要对它的排号进行后移等处理。</li>
</ol>
<h2 id="提出的初步解决方案">提出的初步解决方案</h2>
<h3 id="动画介绍">动画介绍</h3>
<p align="center">
<video width="480" height="320" controls>
<source src="./动画forPPT.mp4">
</video>
</p>
<!-- 需要注意的是：排队的号码不是真实存在的，是商家自己判断的。（这也给商家制造了不少难度）
 -->
<h3 id="对线下和线上排队冲突问题的解决方案">对线下和线上排队冲突问题的解决方案</h3>
<p>为了解决线下和线上排队冲突问题和线上排队用户不能预估时间<br>
根据概率论的知识，排队遵循泊松分布，通过这个原理尝试解决线下和线上排队冲突问题。<br>
<img src="/2019/11/18/Joyeat/泊松分布.png" width="400"></p>
<p align="center">
图：泊松分布
</p>
<p>我们可以通过此规律根据现在排队的人数预估线上排队（多个人）需要等待的时间。为此我们提出了一些算法（由于被新方案抛弃，这里不展开讲）用以辅助 思路二 中商家对线上和线下的冲突处理以及供线上用户参考的预计的排队时间。</p>
<img src="/2019/11/18/Joyeat/线上线下冲突问题.png" width="800">
<p align="center">
问题初步解决思路
</p>
<blockquote>
<p>事已至此，我们研究的新加坡排队现象基本大大缓解。但是我们当然对此并不满意，它的可靠性太低了，太依赖主观的判断。存在诸多的缺陷。</p>
</blockquote>
<h1>问题深究与改进</h1>
<h2 id="改进思路-重新定位产品">改进思路 - 重新定位产品</h2>
<p>我们最大的问题是一开始就想要解决一个非常大的问题（顶天立地），对于情景既没有做任何限制，也没有考虑一些边界情况。这虽然是创新的一个好的苗头，但是创新还是要回归现实的复杂情况，脚踏实地地去做，不要企图一下子解决多个问题。那么遇到太多难题而一筹莫展的时候怎么办？<br>
下面是我的“改进思路”的思路：<br>
由于解决问题的时候四处碰壁，也被很多现实的其他情况问住而无法提出好的解决方案，所以我们其实最需要的是重新思考自己的命题：我们到底要解决什么问题？<br>
新加坡的排队排队现象的缓解。再具体？自顶向下地细化问题、分解问题。<br>
我们不妨缩小考虑问题的范围，先着重考虑一些核心的小的问题。再考虑更加广义的问题，如果更加广义的问题也能够在我们的体系下解决，那我们就基础此合理拓展，到那时如果不能，再去拓展，一定不能破坏原来的体系。而破坏了，那就失去创新的本心了。</p>
<h2 id="原先的问题的细化和分解">原先的问题的细化和分解</h2>
<ol>
<li>排队现象中蕴含的需求。<br>
一个是选择要不要去，辅助用户选择；一个是排队；<br>
区分排队和预定，预定在大餐馆、酒店中已经非常成熟。</li>
<li>场景进一步限定。<br>
新加坡美食广场、小吃街类似的快餐类餐厅，这类餐厅的排队现象严重且受众广泛，而大餐馆、酒店往往是预定机制。有特殊餐饮文化的我们也不应该介入。高档餐厅不追求效率，很多时候的消费点在于舒适体验、服务质量、餐饮文化。</li>
<li>违约问题。<br>
预定有对应的违约金，但是线上排队只是占用线上的名额，没有排到即延后或者丢弃，对双方都没有损失，故不需要考虑。</li>
</ol>
<h2 id="问题的进一步发掘">问题的进一步发掘</h2>
<p>除了我们接触的 NUS 校内的餐馆，新加坡多数的小吃街是怎样的？经过进一步发掘和观察，我们发现为了点餐和取餐的有序性，这类快餐店排队基本都分成两队：Ordering &amp; Collection。</p>
<p align="center">
<img src="/2019/11/18/Joyeat/Order.jpg" width="200/">
</p>
<p align="center">
Order Line
</p>
<p align="center">
<img src="/2019/11/18/Joyeat/Collection.jpg" width="200/">
</p>
<p align="center">
Collection Line
</p>
<p>虽然是快餐，但依据需要服务人员现场制作，并且往往需要耗费一定的时间来制作。所以一般在 Ordering 队伍点餐付款之后需要排到另一个 Collection 队伍，直到取到餐为止才算完整的排队流程。这样点完餐就不会有一堆人无序地在这周围等待自己的食物。像肯德基这样的餐馆往往有一大堆的人点完之后需要反复到前台去确认自己的餐饮是否已经制作完毕。毋庸置疑这样的用餐体验蛮糟糕的。</p>
<p>我们希望的是通过互联网的力量去让用户的体验更好，希望尽可能地消灭排队带来的时间、空间的浪费以及不良的用餐体验。但是问题挖掘到这里，我们会发现 Collection 的队列是无法消灭的，这是由服务人员的生产效率决定的。而我们能消灭的仅仅是 Ordering 的队列。<br>
这一关键点让我们更加明确自己要探讨的排队现象是什么，我们的目标是什么。</p>
<h2 id="新的解决方案——互联网思维带给我们的启示">新的解决方案——互联网思维带给我们的启示</h2>
<p>团队在进行头脑风暴的时候，有人提出了<strong>扫码点餐</strong>的方案，之后全场瞬间炸了，扫码点餐的方案似乎非常好地解决了这个问题。表面上直接消灭 Ordering 的队列！</p>
<h3 id="消失的队列">消失的队列</h3>
<p>静下来仔细，原来的队列哪去了呢？结论是：队伍没有消失，只是换了一种形式存在。<br>
传统的点餐模式是一列人排队，排在第一个的人可以享用点餐的服务，和一列唯一一个柜台的服务员沟通，根据自己的需要点餐付款，然后进入等待期。之后轮到下一人享用服务。<br>
现在的扫描点餐的排队逻辑是怎样的呢？我们不需要排很长的队伍才能和那个一列唯一一个柜台的服务员沟通，告诉他（她）我们需要什么，付款给他（她）。互联网让柜台的服务员可以同时接收所有人的点餐，柜台的服务端相当于有无数个（暂不考虑性能）柜台的服务员为你服务！而你现在在队伍中的次序就是你提交订单的顺序，而计算机提供的时间是毫秒级的，从此不存在插队问题。</p>
<img src="/2019/11/18/Joyeat/排队原理图.png" width="400" align="middle">
<blockquote>
<p>此时不是队伍不存在了，而是队伍已经变成了网络虚拟的形式。</p>
</blockquote>
<h3 id="兼容线上和线下">兼容线上和线下</h3>
<p>扫码点餐甚至解决了线上和线下的冲突问题，能够友好地兼容线上点餐和线下点餐。<br>
之前线上和线下冲突的根本原因是线上和线下的排号在两个体系中，一个是线下的实体队伍有自己的排队序号，一个是线上的有自己的排号序号，而线下的服务提供者只能在一个时间内对一方提供服务。<br>
现在使用扫码点餐的方式，无论线上还是线下都是相同的排号体系，排号的顺序都是根据提交订单的时间次序来决定。故不存在线上和线下冲突的问题。</p>
<h3 id="功能的限定">功能的限定</h3>
<p>之前我们已经对产品的使用场景进行了限定：新加坡美食广场、小吃街类似的快餐类餐厅。<br>
在要解决的问题一（是否选择排队）中，我们提供入驻商家的大量信息，如当前排队人数、营业时间、高峰期、特色等。<br>
故我们会在线上提供商家的信息。<br>
在要解决的问题二（进行线上排队）中，我们不提供远程点餐。原因是远程点餐的情况下，快餐的制作速度还是相对比较快的，点餐的人可能不能及时地到达餐馆取餐，而滞留的食物会占用商家的很多空间。对于美食广场这样的小摊点来说是无法忍受的。<br>
故我们不会直接提供商家点餐的二维码，而会在现场提供点餐的二维码，且对扫描点餐的距离限制在某个范围内（如五百米）</p>
<img src="/2019/11/18/Joyeat/线上线下冲突问题2.png" width="800">
<p align="center">
冲突问题解决最终思路
</p>
<blockquote>
<p>这样一来，大大地解决了排队的问题，还省去了和服务员沟通的成本等。<br>
但是问题还没有完全解决，我们的野心也没有完全实现，缓解排队现象除了省去排队的时间和功夫以外，还要解决排队现象中的另一个隐含的需求：“是否要排队”。<br>
这其实要解决的是客户的选择问题，一方面除了提供已经很普及的电子菜单以外，我们希望做进一步的优化。</p>
</blockquote>
<h3 id="走出一个餐厅的局限">走出一个餐厅的局限</h3>
<p>我们旨在解决新加坡一个快餐领域的一个问题，自然不会局限于某一餐馆，希望更多的商家能够入驻我们的平台，而绝非只是为了某一个商家（如 KFC）开发一个 app，跳出为某一个餐厅和企业的格局，才能创造更大的社会价值。</p>
<h3 id="就餐时间预估">就餐时间预估</h3>
<p>现在我们通过扫码的方式获得已经提交订单的客户的订单信息。完全可以根据这些信息和之前设置的每个菜品制作的时间等，对上菜出单时的时间完成一个客户交易的时间进行预估。预估的结果和其他信息可以反馈给正在排队（考虑是否要来这个餐厅来排队）的用户，辅助用户来决定自己的用餐地点和餐馆。<br>
从更加长远和持久的角度来看，还能对数据进行持续地收集和分析。当然出于用户的个人隐私的考虑，我们要将用户的个人信息滤去，只关注点餐信息本身。从而获得用餐高峰期等有重要参考价值的信息。（借鉴 Google Map 类似的统计）</p>
<h3 id="反馈机制">反馈机制</h3>
<p>之前也提过 KFC 的点餐处理很糟糕的一点是，顾客需要反复到取餐口查看是否轮到自己。虽然服务员会叫号，但是，在嘈杂的环境下，服务员难以保证能让顾客一定能接收到对应的信息，顾客不能保证自己刚好没有做其他事情而忽略了服务员的叫号。有些 KFC 甚至分为上下两层，这种情况下进行等餐的用餐体验一定更加糟糕。<br>
而此时，我们在线上有了有反馈依据的信息，可以实时地反馈给用户当前的排号。并且可以在轮到下一个用户的时候通过手机铃声或者震动的方式提醒用户取餐。<br>
有了这样的反馈之后，用户在提交完订单之后真正地解放了那一段时间。</p>
<h3 id="总体思路">总体思路</h3>
<img src="/2019/11/18/Joyeat/新加坡排队问题.png" width="800/">
<hr>
<h1>新方案的介绍动画</h1>
<br>
<p align="center">
<video width="270" height="480" controls>
<source src="./新方案介绍.mp4">
</video>
</p>
<hr>
<h1>原型展示</h1>
<h2 id="新手教程">新手教程</h2>
<br>
<p align="center">
<video width="270" height="480" controls>
<source src="./Tutorial.mp4">
</video>
</p>
<h2 id="基本使用">基本使用</h2>
<br>
<p align="center">
<video width="270" height="480" controls>
<source src="./Usage.mp4">
</video>
</p>
<hr>
<h1>UX 设计</h1>
<h2 id="Six-Usability-Goals-Design-Principles">Six Usability Goals &amp; Design Principles</h2>
<h3 id="Six-Usability-Goals：">Six Usability Goals：</h3>
<p>Effectiveness、Efficiency、Safety、Learnability、Memorability、Utility.</p>
<blockquote>
<p>Efficiency：How fast / How many step to use the product?<br>
Safety: Easy or not to make mistakes, easy or not to recover, (user can’t do right things always)<br>
Learnability: How easy is a system to learn how to use.<br>
Memorability: How easy to remember how to use a product after learning how to use it?</p>
</blockquote>
<h3 id="Design-Principles：">Design Principles：</h3>
<p>Visibility、feedback、constraints、consistency、affordance.</p>
<blockquote>
<p>Visibility: Make all feature visible.<br>
Feedback: Provide the information about current statement<br>
Constraints: Stop people from it.<br>
Consistency: What we expect.</p>
</blockquote>
<h3 id="设计难点">设计难点</h3>
<p>You can’t be told how to design.<br>
Don’t be afraid of making the mistakes;<br>
Learn from the mistakes;<br>
use more than 20~30% time to try;</p>
<hr>
<h1>参考资料</h1>
<p>[1]（美）詹妮·普瑞斯（Jenny Preece）,（英）伊温妮·罗杰斯（Yvonne Rogers）,（英）海伦·夏普（Helen Sharp）著.《交互设计——超越人机交互》[M].电子工业出版社:北京,2018:10-22</p>
<hr>
<h1>彩蛋 - NUS 美食</h1>
<img src="/2019/11/18/Joyeat/NUS_Food1.jpg">
<br>
<br>
<img src="/2019/11/18/Joyeat/NUS_Food2.jpg">
<br>
<br>
<img src="/2019/11/18/Joyeat/NUS_Food.jpg">]]></content>
      <categories>
        <category>Development</category>
        <category>Mobile</category>
      </categories>
      <tags>
        <tag>Joyeat</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】DDoS原理与防御</title>
    <url>/2019/11/16/DDoS/</url>
    <content><![CDATA[<p>文章转载自：<br>
文章作者:<a href="https://mochazz.github.io" target="_blank" rel="noopener">Mochazz</a><br>
文章链接:<a href="https://mochazz.github.io/2017/09/11/DDOS1/" target="_blank" rel="noopener">https://mochazz.github.io/2017/09/11/DDOS1/</a></p>
<h3 id="0X01DDOS简介"><a href="#0X01DDOS%E7%AE%80%E4%BB%8B" title="0X01DDOS简介"></a>0X01DDOS简介</h3>
<p>DDOS(Distributed Denial of Service)，又称分布式拒绝服务攻击。骇客通过控制多个肉鸡或服务器组成的僵尸网络，对目标发送大量看似合法请求，从而占用大量网络资源，瘫痪网络，阻止用户对网络资源的正常访问。</p>
<a id="more"></a>
<h3 id="0X02DDOS危害"><a href="#0X02DDOS%E5%8D%B1%E5%AE%B3" title="0X02DDOS危害"></a>0X02DDOS危害</h3>
<ol>
<li>出口带宽堵死</li>
<li>游戏掉线导致客户流失</li>
<li>服务器连接数多，连接资源被耗尽</li>
<li>服务器卡、慢、死机、无法连接</li>
</ol>
<h3 id="0X03攻击来源"><a href="#0X03%E6%94%BB%E5%87%BB%E6%9D%A5%E6%BA%90" title="0X03攻击来源"></a>0X03攻击来源</h3>
<ol>
<li>高性能服务器配合发包软件</li>
<li>可联网的设备(如打印机、摄像头、电视等等)</li>
<li>移动设备(数量多，增长速度快，其高性能利于组建僵尸网络)</li>
<li>个人PC(存在漏洞的PC或一些黑客迷自愿成为DDOS一员)</li>
<li>骇客控制的僵尸网络(僵尸网络又分为IRC型、HTTP型、P2P型)</li>
</ol>
<h3 id="0X04流量特点"><a href="#0X04%E6%B5%81%E9%87%8F%E7%89%B9%E7%82%B9" title="0X04流量特点"></a>0X04流量特点</h3>
<ol>
<li>IP地址随机或固定某些IP段随机</li>
<li>没有完整完成三次握手</li>
<li>地址多数是伪造的</li>
<li>请求数量大、快</li>
</ol>
<h3 id="0X05导致DDOS原因"><a href="#0X05%E5%AF%BC%E8%87%B4DDOS%E5%8E%9F%E5%9B%A0" title="0X05导致DDOS原因"></a>0X05导致DDOS原因</h3>
<h4 id="人类因素"><a href="#%E4%BA%BA%E7%B1%BB%E5%9B%A0%E7%B4%A0" title="人类因素"></a>人类因素</h4>
<ol>
<li>金钱利益</li>
<li>政治冲突</li>
<li>宗教冲突</li>
<li>为求出名</li>
</ol>
<h4 id="非人类因素"><a href="#%E9%9D%9E%E4%BA%BA%E7%B1%BB%E5%9B%A0%E7%B4%A0" title="非人类因素"></a>非人类因素</h4>
<ol>
<li>带宽上限</li>
<li>协议缺陷</li>
<li>设备性能上限</li>
<li>应用性能上限</li>
<li>系统性能上限</li>
</ol>
<h3 id="0X06攻击类型及防御"><a href="#0X06%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%E5%8F%8A%E9%98%B2%E5%BE%A1" title="0X06攻击类型及防御"></a>0X06攻击类型及防御</h3>
<h4 id="Smurf攻击"><a href="#Smurf%E6%94%BB%E5%87%BB" title="Smurf攻击"></a>Smurf攻击</h4>
<p>攻击者向网关发送ICMP请求包，并将该ICMP请求报文的源地址伪造成受害主机IP地址，目的地址为广播地址。路由器在接受到该数据包，发现目的地址是广播地址，就会将该数据包广播出去，局域网内所有的存活主机都会受到一个ICMP请求包，源地址是受害主机IP。接下来受害主机就会收到该网络内所有主机发来的ICMP应答报文，通过大量返回的ICMP应答报文来淹没受害主机，最终导致网络阻塞，受害主机崩溃。下面是smurf攻击示意图<br>
<a href="https://mochazz.github.io/img/DDOS1/image2.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image2.png" alt></a><br>
防护方案：</p>
<ol>
<li>禁止路由器广播ICMP请求包；</li>
<li>禁止操作系统对广播发出的ICMP请求包做出响应；</li>
<li>配置防火墙静止来自你所处网络外部的ping包</li>
</ol>
<h4 id="TearDrop攻击"><a href="#TearDrop%E6%94%BB%E5%87%BB" title="TearDrop攻击"></a>TearDrop攻击</h4>
<p>在了解这种攻击之前，需要先知道什么是IP fragmentation（数据包分片）。数据在网络中传输必定会产生数据包被分片，因为每种网络都有不同的最大单个数据包的大小，也就是常说的MTU（Maximum Transmission Unit，最大传输单元）。当要传输的数据超过你要通信的那台主机所处网络的MTU时，数据包就会被分片进行传输，然后在到达目的地再重新组装成原来的数据包，下面是数据包分片重组过程<br>
<a href="https://mochazz.github.io/img/DDOS1/image3.jpeg" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image3.jpeg" alt></a><br>
TearDrop攻击，就是通过设置错误的片偏移，使得数据包到达目的地时，服务器无法重新组合数据包，因为数据包的组合是通过片偏移来组装的，最终导致崩溃。对比一下正常IP数据包和错误IP数据包<br>
<a href="https://mochazz.github.io/img/DDOS1/image4.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image4.png" alt></a><br>
这种攻击主要对旧的windows版本和Linux版本有效，防护的话，可以检测发来的数据包片偏移是否合法，如果合法在组装，不合法直接丢弃。例如这个：<a href="https://wenku.baidu.com/view/b45bba61ddccda38376baf7f.html" target="_blank" rel="noopener">分片重组检查算法</a>。</p>
<h4 id="Land-Attack"><a href="#Land-Attack" title="Land Attack"></a>Land Attack</h4>
<p>攻击者发动Land Attack攻击时，需要先发出一个SYN数据包，并将数据包的源IP与目的IP都设置成要攻击的目标IP，这样目标在接收到SYN数据包后，会根据源IP回应一个SYN+ACK数据包，即和自己建立一个空连接，然后到达idel超时时间时，才会释放这个连接。攻击者发送大量这样的数据包，从而耗尽目标的TCP连接池，最终导致拒绝服务。攻击过程如下<br>
<a href="https://mochazz.github.io/img/DDOS1/image5.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image5.png" alt></a><br>
防御方案参考如下：这种攻击对早期系统有效。通过设置防火墙和路由规则，检测源IP与目的IP相同的数据包，丢弃、过滤这种数据包。</p>
<h4 id="SYN-FLOOD攻击"><a href="#SYN-FLOOD%E6%94%BB%E5%87%BB" title="SYN FLOOD攻击"></a>SYN FLOOD攻击</h4>
<p>SYN FLOOD攻击是在TCP三次握手过程中产生的。攻击者通过发送大量伪造的带有SYN标志位的TCP报文，与目标主机建立了很多虚假的半开连接，在服务器返回SYN+ACK数据包后，攻击者不对其做出响应，也就是不返回ACK数据包给服务器，这样服务器就会一直等待直到超时。这种攻击方式会使目标服务器连接资源耗尽、链路堵塞，从而达到拒绝服务的目的。SYN FLOOD攻击图示如下<br>
<a href="https://mochazz.github.io/img/DDOS1/image6.jpeg" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image6.jpeg" alt></a><br>
防御：<br>
SYNCheck：使用防护设备，3次握手变成了6次握手，由防护设备检测SYN请求是否合法，通过后再由防护设备将报文转发给服务器，后续报文仍由防护设备代理。<br>
Micro blocks：管理员可以在内存中为每个SYN请求创建一个小索引(小于16字节)，而不必把整个连接对象存入内存。<br>
RST cookies：在客户端发起第一个SYN请求后，服务器故意回应一个错误的SYN+ACK报文。如果合法用户收到这个报文，就会给服务器响应RST报文。当服务器收到这个报文时，就将这个主机的IP记录进合法IP列表，下次该主机发起SYN请求时，就可以直接通过了。<br>
STACK tweaking：管理员可以调整TCP堆栈以减缓SYN泛洪攻击的影响。这包括减小超时时间，等到堆栈存释内放时再分配连接，否则就随机性地删除传入的连接。</p>
<h4 id="ACK-FLOOD攻击"><a href="#ACK-FLOOD%E6%94%BB%E5%87%BB" title="ACK FLOOD攻击"></a>ACK FLOOD攻击</h4>
<p>ACK FLOOD攻击是利用TCP三次握手过程。这里可以分为两种。</p>
<p>第一种：攻击者伪造大量的SYN+ACK包发送给目标主机，目标主机每收到一个SYN+ACK数据包时，都会去自己的TCP连接表中查看有没有与ACK的发送者建立连接 ，如果有则发送ACK包完成TCP连接，如果没有则发送ACK+RST 断开连接。但是在查询过程中会消耗一定的CUP计算资源。如果瞬间收到大量的SYN+ACK数据包，将会消耗服务器的大量cpu资源，导致正常的连接无法建立或增加延迟，甚至造成服务器瘫痪、死机。<br>
<a href="https://mochazz.github.io/img/DDOS1/image7.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image7.png" alt></a></p>
<p>第二种：利用TCP三次握手的ACK+SYN应答，攻击者向不同的服务器发送大量的SYN请求，这些SYN请求数据包的源IP均为受害主机IP，这样就会有大量的SYN+ACK应答数据包发往受害主机，从而占用目标的网络带宽资源，形成拒绝服务。<br>
<a href="https://mochazz.github.io/img/DDOS1/image8.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image8.png" alt></a><br>
通常DDOS攻击会将ACK flood与SYN flood结合在一起，从而扩大威力。防御方案可参考如下：采用CDN进行流量稀释；避免服务器IP暴露在公网上；通过限速或动态指纹的方式；利用对称性判断来分析出是否有攻击存在；在连续收到用户发送的ACK包时，中断回话，让其重连。</p>
<h4 id="UDP-FLOOD攻击"><a href="#UDP-FLOOD%E6%94%BB%E5%87%BB" title="UDP FLOOD攻击"></a>UDP FLOOD攻击</h4>
<p>UDP（User Datagram Protocol，用户数据报协议），是一种无连接和无状态的网络协议，UDP不需要像TCP那样进行三次握手，运行开销低，不需要确认数据包是否成功到达目的地。这就造成UDP泛洪攻击不但效率高，而且还可以在资源相对较少的情况下执行。UDP FLOOD可以使用小数据包(64字节)进行攻击,也可以使用大数据包(大于1500字节,以太网MTU为1500字节)进行攻击。大量小数据包会增大网络设备处理数据包的压力；而对于大数据包，网络设备需要进行分片、重组，最终达到的效果就是占用网络传输接口的带宽、网络堵塞、服务器响应慢等等。<br>
<a href="https://mochazz.github.io/img/DDOS1/image9.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image9.png" alt></a><br>
防御方案：限制每秒钟接受到的流量(可能产生误判)；通过动态指纹学习(需要攻击发生一定时间)，将非法用户加入黑名单。</p>
<h4 id="NTP放大攻击"><a href="#NTP%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB" title="NTP放大攻击"></a>NTP放大攻击</h4>
<p>NTP(Network Time Protocol，网络时间协议)，是用来使计算机网络时间同步化的一种协议，它可以使计算机与时钟源进行同步化并提供高精度的时间校正，使用UDP123端口进行通信。通常在NTP服务器上会有一些调试接口，而利用这些接口中的monlist请求，就可触发放大攻击。当主机向NTP服务器发送monlist查询请求时，NTP服务器会将与之进行时间同步的最后600个IP地址返回。所以攻击者只需要将源地址伪造为受害主机的IP，向NTP服务器发送一个monlist查询请求包，受害主机就会收到大量的UDP响应包。这种攻击在放大攻击里，危害相对较大。下面是NTP放大攻击示意图<br>
<a href="https://mochazz.github.io/img/DDOS1/image10.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image10.png" alt></a><br>
总结一下这种攻击产生的原因，请求与响应数据包不等价；UDP协议的通信模糊性（无数据传输确认机制）；以及NTP服务器的无认证机制。<br>
防御方案：</p>
<ol>
<li>使用防 DDoS 设备进行清洗；</li>
<li>加固并升级NTP服务器；</li>
<li>在网络出口封禁 UDP 123 端口；</li>
<li>通过网络层或者借助运营商实施 ACL 来防御；</li>
<li>关闭现在 NTP 服务的 monlist 功能，在ntp.conf配置文件中增加<code>disable monitor</code>选项。</li>
</ol>
<h4 id="DNS放大攻击"><a href="#DNS%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB" title="DNS放大攻击"></a>DNS放大攻击</h4>
<p>DNS(Domain Name System，域名系统)，由于使用IP地址来记忆各个网站比较困难，所以就产生了使用主机名称来表示对应的服务器，主机名称通过域名解析的过程转换成IP地址。下面来看一下DNS报文格式，以便了解攻击发生在何处。<br>
<a href="https://mochazz.github.io/img/DDOS1/image11.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image11.png" alt></a><br>
报文首部格式<br>
<a href="https://mochazz.github.io/img/DDOS1/image12.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image12.png" alt></a><br>
报文首部各字段含义如下，其中绿色高亮是攻击点之一，之后会分析<br>
<a href="https://mochazz.github.io/img/DDOS1/image13.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image13.png" alt></a><br>
下面是问题记录中查询类型可设置的值，我们发现最后一个ANY类型会请求所有记录，这也是一个攻击点<br>
<a href="https://mochazz.github.io/img/DDOS1/image14.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image14.png" alt></a><br>
DNS查询可分为递归查询和迭代查询，下面是DNS迭代查询图<br>
<a href="https://mochazz.github.io/img/DDOS1/image15.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image15.png" alt></a><br>
再来看DNS递归查询图<br>
<a href="https://mochazz.github.io/img/DDOS1/image16.jpeg" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image16.jpeg" alt></a><br>
从DNS数据包结构以及DNS递归查询过程，我们就可以大致分析出攻击原理。首先，攻击者向僵尸网络发出指令，使僵尸网络中的每一台主机均发出一个伪造源地址的DNS查询请求包，这些请求包查询类型设置为ANY，因为这种类型会请求所有的记录，这些记录会在返回的响应包中，也就是说这种数据包的大小较其他类型是最大的。接着查询类型设为递归查询，为什么不是迭代查询呢，仔细看两种查询的过程图可发现，如果迭代查询第一个请求的DNS服务器没有查询到结果，那么第一个请求的服务器会返回另一个DNS服务器IP，让请求主机向这个IP去继续查询，然而攻击者的数据包源地址是伪造的，所以并不会发起第二次查询，因为第一次查询根本就不是它发起的；而递归查询却是在查询到结果之后，才返回给查询请求发起者。利用这两个特点，攻击者就可以成功发起DNS放大攻击。这种普通的查询请求可以将攻击流量放大2~10倍，如果想增大攻击倍数，可以使用RFC 2671中定义的DNS拓展机制EDNS0。未使用EDNS0时，若响应包大小小于512字节，就使用UDP封装数据；若响应包大小超过512字节，就使用TCP连接或者服务器截断响应报文，丢弃超过512字节的部分，并把TC位置1。这两种方式都不利于进行DNS放大攻击。然而在开启EDNS0机制后，增加了OPT RR字段，这两个字段包含了能够处理的最大UDP报文大小信息，所以攻击者将这个信息设置的很大，服务器就会根据这个信息生成响应报文。最后看一下DNS放大攻击演示图<br>
<a href="https://mochazz.github.io/img/DDOS1/image17.jpeg" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image17.jpeg" alt></a><br>
防御策略：</p>
<ol>
<li>联系ISP清洗上游流量；</li>
<li>DNS服务器只对可信域内提供服务，限制对域外用户提供DNS解析服务；</li>
<li>对单个IP的查询速率做限制；</li>
<li>拥有足够的带宽承受小规模攻击；</li>
<li>关闭DNS服务器的递归查询；</li>
<li>利用防火墙等对ANY Request进行过滤。</li>
</ol>
<h4 id="SNMP放大攻击"><a href="#SNMP%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB" title="SNMP放大攻击"></a>SNMP放大攻击</h4>
<p>SNMP(Simple Network Management Protocol，简单网络管理协议)，是目前网络中应用最为广泛的网络管理协议，它提供了一个管理框架来监控和维和互联网设备，它使用UDP161端口进行通信。攻击者向互联网上开启SNMP服务的设备发送GetBulk请求，并使用默认通信字符串作为认证凭据。常见的默认通信字符串如public、private以及一些厂商默认的通信字符串。GetBulk请求是在SNMPv2中添加的的，该请求会让SNMP设备尽可能多的返回数据，这也就是SNMP放大攻击的利用点。下面来看一下SNMP的PDU格式<br>
<a href="https://mochazz.github.io/img/DDOS1/image18.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image18.png" alt></a><br>
攻击者先将源地址改成要攻击的目标IP，再使用默认的通信字符串，向大量SNMP设备发出GetBulk请求，设备收到GetBulk请求数据包后，会将一大段的设备检索信息返回给目标主机，最终目标主机会被这些SNMP设备返回的数据包淹没，导致拒绝服务。看一下SNMP的攻击图<br>
<a href="https://mochazz.github.io/img/DDOS1/image19.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image19.png" alt></a><br>
防御策略：</p>
<ol>
<li>禁止已开启SNMP的设备响应GetBulk请求，避免自己的设备被黑客利用；</li>
<li>更改默认的通信字符串；</li>
<li>修改默认端口161；</li>
<li>隐藏开启SNMP设备的公网IP。</li>
</ol>
<h4 id="TFTP放大攻击"><a href="#TFTP%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB" title="TFTP放大攻击"></a>TFTP放大攻击</h4>
<p>TFTP（Trivial File Transfer Protocol，简单文件传输协议），使用UDP 69端口进行通信，由于TFTP使用的是不可靠的UDP协议，所以他不能确保发送的任何报文都能真正到达目的地，因此他必须使用定时器来检测并重传报文，以下是TFTP传输文件过程图<br>
<a href="https://mochazz.github.io/img/DDOS1/image20.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image20.png" alt></a><br>
超时重传机制<br>
<a href="https://mochazz.github.io/img/DDOS1/image21.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image21.png" alt></a><br>
可以看到，TFTP协议将数据分成好多个数据块进行传输，每个数据块最大为512字节，客户端在接受到数据块时，需要给服务器端返回一个ACK确认报文，然后才会继续传输下一个报文。若服务器没有收到客户端发来ACK报文，则在时间到达超时计数器时，便会开启重传机制，这也就是攻击利用点。攻击者利用TFTP协议上的缺陷，伪造源地址向服务器发起请求，服务器回复的第1个data数据包后无法收到客户端发送的ACK。此时TFTP就会利用他的重传机制，定时重传第1个data数据包，当攻击者发出大量的这种请求时，TFTP放大攻击也就发生了。来看一下TFTP放大攻击示意图<br>
<a href="https://mochazz.github.io/img/DDOS1/image22.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image22.png" alt></a><br>
防御方案:</p>
<ol>
<li>不要将TFTP服务器暴露在公网上；</li>
<li>对流经TFTP服务的流量进行入侵检测；</li>
<li>将重传（数据包）率设置为1；只为信任域内的主机提供服务。</li>
</ol>
<h4 id="CC攻击"><a href="#CC%E6%94%BB%E5%87%BB" title="CC攻击"></a>CC攻击</h4>
<p>CC攻击（ChallengeCollapsar）又称作HTTP 泛洪攻击，其原理是攻击者控制肉鸡、僵尸网络或使用代理服务器，不停地向目标的web服务发送大量合法请求，使得正常用户的web请求处理缓慢甚至得不到处理，制造大量的后台数据库查询动作，消耗目标CPU资源，最终导致服务器宕机崩溃。这种攻击方式不需要很大的带宽，且无法使用伪造IP地址进行攻击，需要真实的机器与web服务器建立连接，因为HTTP协议是建立在TCP协议上，必须先进行TCP三次握手才能进行HTTP通信。如果目标web服务器支持HTTPS，那么发起的HTTPS泛洪攻击还能穿透一些防护设备。<br>
<a href="https://mochazz.github.io/img/DDOS1/image23.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image23.png" alt></a><br>
防御方案：</p>
<ol>
<li>必要时将网页做成静态，减少数据库的使用；</li>
<li>限制连接数量；</li>
<li>修改最大超时时间；</li>
<li>让用户手动输入验证码；</li>
<li>在response报文中添加特殊字段，验证IP合法性；</li>
<li>屏蔽频繁访问服务器的主机IP。</li>
</ol>
<h4 id="HTTP慢速攻击"><a href="#HTTP%E6%85%A2%E9%80%9F%E6%94%BB%E5%87%BB" title="HTTP慢速攻击"></a>HTTP慢速攻击</h4>
<p>Slow HTTP Dos AttACKs（慢速HTTP拒绝服务攻击），黑客模拟正常用户向web服务器发送慢速http请求，由于是慢速的，服务器端需要保持连接资源，直到数据传输结束或请求结束才可释放连接。当服务器端建立了大量这样的慢速连接，就会导致服务器拒绝服务。这种攻击可以分为两类，一类是客户端发数据，另一类是客户端读取服务器发来的数据。HTTP慢速攻击对基于线程处理的web服务器影响显著，如apache、dhttpd，而对基于事件处理的web服务器影响不大，如ngix、lighttpd。HTTP慢速攻击还可以细分成以下几种攻击方式.</p>
<p>Slowloris攻击方式<br>
HTTP协议规定请求头以一个空行结束，所以完整的http请求头结尾是\r\n\r\n。然而使用非正常的\r\n来结尾，就会导致服务端认为我们的请求头还没结束，等待我们继续发送数据直到超时时间。两种请求头区别如下，CRLF（Carriage Return Line Feed）表示回车换行<br>
<a href="https://mochazz.github.io/img/DDOS1/image24.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image24.png" alt></a></p>
<p>Slow post攻击方式<br>
在http头部信息，可以使用content-length声明HTTP消息实体的传输长度，服务器端会content-length的值作为HTTP BODY的长度。利用这一特点，攻击者把content-length设置得很大的，然后缓慢发送数据部分，比如一次只发送一个字节，这样服务器端就要一直保持连接，直到客户端传完所有的数据。<br>
<a href="https://mochazz.github.io/img/DDOS1/image25.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image25.png" alt></a></p>
<p>Slow read攻击方式<br>
攻击者发送一个完整的HTTP数据请求，之后服务器会给出响应，这时攻击者在将自己的TCP窗口大小设置的很小，服务器会根据客户的TCP窗口大小来传送数据。由于客户端的TCP窗口大小很小，服务器只能缓慢的传输数据给客户端。当建立大量的这种连接时，web应用的并发连接池将被耗尽，最终导致拒绝服务。<br>
<a href="https://mochazz.github.io/img/DDOS1/image26.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image26.png" alt></a></p>
<p>Apache range header攻击<br>
这种攻击方式只针对apache，当客户端传输大文件时会有range字段，表示将大文件分段，分成几个小段进行传输。例如攻击者将一个文件按照一个字节一段，分成好多段，这样就会造成传输数据缓慢，长时间占用连接，消耗服务器CPU和内存资源。<br>
上面这4种攻击方式，也可以参考这篇文章：CC攻击。了解了攻击原理，我们就可以有针对性地进行防御，这里说一下apache的防护策略：设置并使用以下模块<br>
mod_reqtimeout模块，控制请求数据传输的超时时间及最小速率，防护配置如下<br>
<a href="https://mochazz.github.io/img/DDOS1/image27.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image27.png" alt></a><br>
mod_qos模块，Apache的一个服务质量控制模块，用户可配置各种不同阈值，防护配置如下<br>
<a href="https://mochazz.github.io/img/DDOS1/image28.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image28.png" alt></a><br>
mod_security模块，一个开源的WAF模块，有专门针对慢速攻击防护的规则，防护配置如下<br>
<a href="https://mochazz.github.io/img/DDOS1/image29.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image29.png" alt></a><br>
以上是针对Apache的一些防护策略，至于其他中间件的防护，可以参考这篇文章：<a href="https://blog.qualys.com/securitylabs/2011/11/02/how-to-protect-against-slow-http-attacks" target="_blank" rel="noopener">How to Protect Against Slow HTTP AttACKs</a></p>
<h4 id="XSS-DOS"><a href="#XSS-DOS" title="XSS-DOS"></a>XSS-DOS</h4>
<p>利用网站存在的存储型XXS漏洞，在网站中插入恶意的javascript代码。代码的功能是不断向web服务器发起大量请求，从而导致服务器宕机，无法响应正常用户的请求。客户端访问已插入恶意的javascript代码的页面后，抓包截图如下<br>
<a href="https://mochazz.github.io/img/DDOS1/image30.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image30.png" alt></a><br>
由于这种攻击的是由存储型XSS导致的，我们再防御方面就要考虑如何防御存储型XSS。<br>
防御策略：</p>
<ol>
<li>对用户的输入以及url参数进行特殊字符过滤；</li>
<li>对输出内容进行编码转换；</li>
<li>结合黑白名单机制。</li>
</ol>
<h4 id="时间透镜攻击"><a href="#%E6%97%B6%E9%97%B4%E9%80%8F%E9%95%9C%E6%94%BB%E5%87%BB" title="时间透镜攻击"></a>时间透镜攻击</h4>
<p>通过控制相同源和相同目的IP报文，使得走不同路径的数据包，在同一时刻到达目标服务器，从而达到流量集中攻击的目的。这种攻击其实我也还弄不太懂，详细信息可以阅读这篇paper：<a href="http://icir.org/vern/papers/lensing.oak15.pdf" target="_blank" rel="noopener">Temporal Lensing and its Application in Pulsing Denial-of-Service Attacks</a>，或者看这个<a href="https://www.youtube.com/watch?v=QwAHNnKDVxQ" target="_blank" rel="noopener">视频</a>，还有这份中文分析：<a href="https://mp.weixin.qq.com/s?__biz=MzI2NjUwNjU4OA==&amp;mid=2247483685&amp;idx=1&amp;sn=8ac38ff22d571bbbf7716cb9e83b9b35&amp;chksm=ea8c5916ddfbd00008d9b28e22fccba8c201ce78c70c2d78d10ee732f22a39ccf46d4b197634&amp;mpshare=1&amp;scene=23&amp;srcid=0831Wr5YJPYzSrQU6gnfGVd0" target="_blank" rel="noopener">时间透镜及其在脉冲拒绝服务攻击的应用</a>。看一下freebuf上的一个分析图<br>
<a href="https://mochazz.github.io/img/DDOS1/image31.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image31.png" alt></a><br>
<a href="https://mochazz.github.io/img/DDOS1/image32.png" target="_blank" rel="noopener"><img src="https://mochazz.github.io/img/DDOS1/image32.png" alt></a><br>
防御方案：增加抖动，干扰攻击路径，使得数据包无法预期到达；由运营商禁止源路由。<br>
其他防御措施：</p>
<ol>
<li>采用高性能的网络设备；</li>
<li>充足的网络带宽保证；</li>
<li>升级主机服务器硬件；</li>
<li>避免将服务器的真实IP暴露在公网中；<br>
使用CDN对流量进行稀释，当大流量稀释到各个CDN节点时，再对流量进行清洗，从而达到防护源站的目的。然而这种防御方式只能用在对域名发起的DDOS攻击，如果攻击者直接对IP进行攻击，则需要使用anycast技术来防御。</li>
</ol>
<h3 id="0X07总结"><a href="#0X07%E6%80%BB%E7%BB%93" title="0X07总结"></a>0X07总结</h3>
<p>这篇文章是自己对DDOS学习的一个总结，当中参考了不少文章书籍，当然还有很多类型的DDOS文中未提及，需要再深入学习，文中若有原理性错误，还望大家指出修正。如果大家有什么好的书籍或关于这方面的资料，欢迎推荐、交流，文章仅用于研究，切勿用在非法用途。在下一篇文章中，我将还原大部分DDOS攻击的场景。</p>
<p>参考：</p>
<ol>
<li><a href="http://www.jianshu.com/p/dff5a0d537d8" target="_blank" rel="noopener">CC攻击</a></li>
<li><a href="https://www.incapsula.com/ddos/attack-glossary/http-flood.html" target="_blank" rel="noopener">HTTP FLOOD</a></li>
<li><a href="https://www.incapsula.com/ddos/attack-glossary/udp-flood.html" target="_blank" rel="noopener">UDP FLOOD</a></li>
<li><a href="https://www.webnms.com/snmp/help/snmpapi/snmpv3/snmp_operations/snmp_getbulk.html" target="_blank" rel="noopener">SNMP GETBULK</a></li>
<li><a href="https://www.incapsula.com/ddos/attack-glossary/smurf-attack-ddos.html" target="_blank" rel="noopener">SMURF DDOS ATTACK</a></li>
<li><a href="https://wenku.baidu.com/view/436588f4f61fb7360b4c65a1.html" target="_blank" rel="noopener">DNS Amplification AttACK</a></li>
<li><a href="https://www.us-cert.gov/ncas/alerts/TA14-013A" target="_blank" rel="noopener">NTP Amplification AttACKs Using CVE-2013-5211</a></li>
<li><a href="https://www.incapsula.com/ddos/attack-glossary/snmp-reflection.html" target="_blank" rel="noopener">SNMP REFLECTION/AMPLIFICATION</a></li>
<li><a href="https://www.acunetix.com/blog/articles/slow-http-dos-attacks-mitigate-apache-http-server/" target="_blank" rel="noopener">How To Mitigate Slow HTTP DoS AttACKs in Apache HTTP Server</a></li>
<li><a href="https://blog.qualys.com/securitylabs/2011/11/02/how-to-protect-against-slow-http-attacks" target="_blank" rel="noopener">How to Protect Against Slow HTTP AttACKs</a></li>
<li><a href="http://icir.org/vern/papers/lensing.oak15.pdf" target="_blank" rel="noopener">Temporal Lensing and its Application in Pulsing Denial-of-Service Attacks</a></li>
<li>《TCP-IP协议族(第4版)》</li>
<li>《破坏之王-DDoS攻击与防范深度剖析》</li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
        <category>DDoS</category>
      </categories>
  </entry>
  <entry>
    <title>“阅享成电” - 生命本来没有名字</title>
    <url>/2019/11/10/%E7%94%9F%E5%91%BD%E6%9C%AC%E6%9D%A5%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<h3 id="引言">引言</h3>
<p>这次的主题是“不忘初心”。<br>
“不忘初心”这个词自从习大大在十九大在全党开展“不忘初心、牢记使命”主题教育之后就特别火。而且也因此开始和“牢记使命”这个词牵连在一起，和“新时代”联系在一起。<br>
今天我想摆脱这个牵连关系：不谈使命，谈意义；不谈新时代，谈生命本身。</p>
<p>今天分享的是阅读周国平先生的散文《生命本来没有名字》过程中产生的感悟。</p>
<a id="more"></a>
<h3 id="生命的初心">生命的初心</h3>
<h4 id="问题的起源">问题的起源</h4>
<p>我们常谈做一件事情的初心是什么，却很少思考生命的初心是什么。<br>
做一件事有它的目的，所以自然能探索到它的初心，它是为什么而诞生的。那么在宇宙间偶然的偶然中诞生的生命又怎么去谈它的初心？从这一点看，似乎无从谈起。但我想探索的不是给每一个生命都定一个它存在的意义，而是反向去找它不应该变成什么样子。而周国平先生的观点无意间回答了我这个问题：生命本来没有名字。</p>
<h4 id="名字对生命的侵犯">名字对生命的侵犯</h4>
<p>我们一出生，就被父母赋予了名字，而这个名字往往给予了父母对我们的期望和很多其他的关系。比如名字“xxx”，姓氏缔结了和家族的联系，名称寄予了父母希望我的一生能往怎样的方向发展（有点情况是未完成愿望之诅咒）。再后来，我们进了幼儿园，进了小学、中学、大学，越来越多的东西和名字有了牵连。比如，我们期待在学校的排行榜上出现自己的名字，我们期待奖状上附上自己的名字，希望自己的称谓里还带着一些头衔，在以后真正踏入社会可能更是如此。（大家可以仔细回想自己生命中的这些常见）<br>
但用周国平的话讲就是：</p>
<blockquote>
<p>随着我们长大，越来越深地沉溺于俗务琐事，已经很少有人能记起这个最单纯的事实了。<br>
我们彼此以名字相见，名字又与头衔、身份 、财产之类相连，结果，在这些寄生物的缠绕之下，生命本身隐匿了，甚至萎缩了。无论对己对人，生命的感觉都日趋麻痹。多数时候，我们只是作为一个称谓活在世上。即使是朝夕相处的伴侣，也难得以生命的本然状态相待，更多的是一种伦常和习惯。</p>
</blockquote>
<h4 id="名字对生命中的爱情">名字对生命中的爱情</h4>
<p>也受这个影响，在我心里，爱情有三种境界。<br>
第一种是最广泛存在的最平凡最普通的爱情，也是最受“名字”本身影响的爱情。<br>
在弗洛姆的《爱的艺术》中描述了这种普遍的爱情：</p>
<blockquote>
<p>在一个商业化占统治地位以及物质成果看得高于一切的文化中，人与人之间的爱情关系也遵循着同控制商品和劳动市场一样的基本准则。<br>
归根结底爱情的产生是以权衡对方及本人的交换价值为前提的。<br>
——《爱的艺术》（弗洛姆）</p>
</blockquote>
<p>第二种是慢慢淡去那种衡量“配不配得上”、“值不值得追求”这些观念观念，而转向一种纯粹的生活的深情。</p>
<blockquote>
<p>我不会说美好的情话，我只在柴米油盐中伴你走过每一天。内裤和内裤晾在一起，名字和名字刻在一起。你在，吵得天翻地覆；你走了，在你坟前轻轻地哭。<br>
—— 《名字和名字刻在一起》（路明）</p>
</blockquote>
<p>第三种境界是这篇文章描述的那种，它是从反面去讲的。</p>
<blockquote>
<p>你说你爱你的妻子，可是，如果你不是把她当作一个独一无二的生命来爱，那么你的爱还是比较有限。你爱她的美丽、温柔、贤惠 、聪明，当然都对，但这些品质在别的女人身上也能找到。惟独她的生命，作为一个生命体的她，却是在普天下的女人身上也无法重组或再生的，一旦失去，便是不可挽回地失去了。 世上什么都能重复，恋爱可以再谈，配偶可以另择，身份可以炮制，钱财可以重挣，甚至历史也可以重演，惟独生命不能。<br>
——《生命本来没有名字》（周国平）</p>
</blockquote>
<h3 id="生命的意义">生命的意义</h3>
<p>同样的，我谈不了生命的意义，但是想讲讲生命不该丧失什么。也以此作结。</p>
<blockquote>
<p>浩瀚宇宙间，也许只有我们的星球开出了生命的花朵，可是，在这个幸运的星球上，比比皆是利益的交换，身份的较量，财产的争夺，最罕见的偏偏是生命与生命的相遇。仔细想想，我们是怎样地本末倒置，因小失大，辜负了造化的宠爱。<br>
我相信，对于生命的这种珍惜和体悟乃是一切人间之爱的至深的源泉。</p>
</blockquote>
]]></content>
      <categories>
        <category>Life</category>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>SDN 实验笔记</title>
    <url>/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="初衷">初衷</h2>
<p>写这篇文章的目的是：之前完全照搬 SDN 指导书上的各个命令。即便事后有整理理论知识，但也不免严重遗忘、变得模糊。<br>
有点像以为使用记忆的方法就能掌握编程那样荒谬。<br>
先从实验入手往往容易造成的这样巨大的问题：得知其然而不知其所以然。<br>
这算是挑战性课程给我们的一个比较大的教训。虽然过去自己在捣腾东西的时候，已经体会到了局部。但是这次挑战性课程的容量以及时间对我们的压力，让我对它有了更深的理解。<br>
尤其是实验室还一直催着我们向前，但是在不断前行的时候，我发现自己的地基没有打好，所以这才匆匆的回头重新打地基。</p>
<a id="more"></a>
<p>比如很多环境的配置可能配一遍之后，以后再也记不得当初是怎么配的了。<br>
当然这只是举个例子。因为环境往往只需要搭建，最多只需要把当时配置的过程记录下来，而不需要记入到脑中。也因此这里也不再赘述环境的配置。（其实有些配环境的部分也是有方法技巧的）<br>
但是我们做的这个实验，除了最开始的搭建部分后面的很多地方，其实在未来还会反复的使用。实验指导书给出了一个例子。但是不过脑子地、照抄的话，是没办法实现举一反三，实现真正的学习的。</p>
<h2 id="实验环境">实验环境</h2>
<h3 id="Linux">Linux</h3>
<p>当初并没有重视 VMWare Tools，也觉得它不太可靠（某人因为它死了进程）。所以就用云把需要的文件全部同步过去、用 Git 把需要的代码也拷过去。这样就能完全在 Linux 环境下进行正常的开发了……<br>
然而 VCode 经常在 Linux 里面崩溃，且在虚拟机中运行也不流畅。<br>
所以最后决定把文件移除到需要的时候再直接复制进去……<br>
也能避免虚拟机的存储空间不足的情况。<br>
// 不过至少这个过程也让我更熟练地使用Linux，包括各种异常的处理。</p>
<h3 id="OVS">OVS</h3>
<p>这一个实验不需要过分深究，用此明白Mininet的原理即可。所以这里就不再复现。</p>
<blockquote>
<p>一般来说，通过 Mininet 启动的交换机都是 OVS.<br>
也就是说，在安装 Mininet 的时候，默认已经把 OVS 这个开源程序安装上了，在用 Mininet 启动网络的时候，OVS 进程也跟着启动了，所以，在本机的命令行下是可以直接调ovs-ofctl和ovs-vsctl等OVS的专属命令的。</p>
</blockquote>
<p>不过 OVS 还可以查看流表什么的…… （之后再回来看看……）</p>
<h3 id="minint">minint</h3>
<p>由于拓扑的脚本还是放在原来的仓库下面:（自己要熟练地找自己存放的目录）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/SDN-dev/Code</span><br><span class="line">sudo mn -c</span><br><span class="line">sudo mn --custom xx.py --topo xxtopo -controller=remote,ip=127.0.0.1,port=6653</span><br></pre></td></tr></table></figure>
<h3 id="ODL">ODL</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo SDN-dev/karaf-0.8.2/bin/karaf</span><br></pre></td></tr></table></figure>
<h3 id="各个部分的关系">各个部分的关系</h3>
<p>OVS 用于模拟真实的交换机；<br>
Mininet 用于搭建虚拟网络拓扑,模拟 SDN 转发设备层。<br>
OpenDayliht 则作为控制器层,对 Mininet 搭建的网络进行拓扑展示和控制管理</p>
<p>最开始通过 mininet 建立网络拓扑，并连接到控制器的 ip 地址上。<br>
然后打开 ODL，以及<code>http://localhost:8181/index.html</code>，(默认用戶名与密码均为admin)即可可视化拓扑。<br>
但是此时显示的一般只是交换机，只有在 mininet 终端中 <code>pingall</code> 之后才会 <code>reload</code> 之后才会显示主机，没有 ping 通的就不会显示。</p>
<h2 id="实验">实验</h2>
<h3 id="mininet">mininet</h3>
<p>Mininet仅为SDN网络的基础设施，明白其简单命令及其具有的功能即可，在需要的时候可以查阅文档等。</p>
<h4 id="常见命令">常见命令</h4>
<p>进入 mininet 的终端之后可以用对应的命令进行拓扑的创建和修改。</p>
<h5 id="进入-退出-命令：">进入/退出 命令：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@ubuntu:~$ sudo mn --controller=remote,ip=192.168.15.23,port=6653 // 产生默认拓扑,指向远端控制器</span><br><span class="line">mininet&gt; pingall //连通所有链路</span><br><span class="line">mininet&gt; quit/<span class="built_in">exit</span> //退出 mininet</span><br><span class="line">user@ubuntu:~$ sudo mn –c//退出 mininet 并清除拓扑</span><br></pre></td></tr></table></figure>
<p><code>mn</code>如果没有参数（默认创建的拓扑）：<br>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/default mininet.png" width="500"></p>
<p>常用命令参数<br>
<code>--controller</code>：可以用于添加控制器。<br>
一般连接远程控制器可以使用<code>--controller=remote,ip=xxx.xx.xx.xx,port=6653</code>。（注意没有空格…）<br>
<code>--custom</code>：后面跟自己编写的拓扑Python脚本的路径。<br>
<code>--topo</code>：可以选择linear、minimal、single、tree等多种模式，模式后面可以加参数，如命令mn --topo single,2就相当于mn.（mn 默认的方式）<br>
<code>--mac</code>：添加此选项可以让主机的MAC地址有规律，即00:00:00:00:00:01依次排列<br>
<code>--link</code>：在Python脚本中有对链路贷款、时延约束的情况下可以添加–link=tc<br>
<code>-c</code>：清理创建的网络拓扑，在结束Mininet后使用命令mn -c清理是一个好习惯</p>
<p><code>--topo=linear,5</code> 相当于五个交换机串联，每个交换机都挂一个主机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=linear,5 --controller=remote,ip=127.0.0.1,port=6653</span><br></pre></td></tr></table></figure>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/linear.png" width="500">
<p><code>--topo=tree,5</code> 像二叉树，主机是叶子结点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=tree,3 --controller=remote,ip=127.0.0.1,port=6653</span><br></pre></td></tr></table></figure>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/tree5.png" width="500">
<p>…<br>
（其他的以后再玩玩）</p>
<blockquote>
<p>下面在 minin 的命令行的图片是以下面的拓扑为例的。<br>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/Topo.png" width="500"></p>
</blockquote>
<h5 id="全局命令：">全局命令：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mininet&gt; <span class="built_in">help</span>   //显示可以使用的命令</span><br><span class="line">mininet&gt; nodes  //查看全部节点</span><br><span class="line">mininet&gt; net    //查看链路信息</span><br><span class="line">mininet&gt; dump   //输出各节点的信息</span><br></pre></td></tr></table></figure>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/Allequment.png" width="500">
<h5 id="对单个网络设备的配置：">对单个网络设备的配置：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mininet&gt; s1 ifconfig        //查看交换机 s1 上的网络信息</span><br><span class="line">mininet&gt; h1 ping -c 3 h2    //用 ping 3 个包的方法来测试 h1 跟 h2 之间连通情况</span><br><span class="line">mininet&gt; xterm h1           //打开主机 h1 的终端（貌似不行</span><br></pre></td></tr></table></figure>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/s1ifconfig.png" width="500">
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/h1h2ping.png" width="500">
<blockquote>
<p>更多命令参数可以参考如下网址自主学习:<br>
<a href="https://blog.csdn.net/u014015972/article/details/51133292" target="_blank" rel="noopener">https://blog.csdn.net/u014015972/article/details/51133292</a></p>
</blockquote>
<h4 id="用-Python-建立拓扑">用 Python 建立拓扑</h4>
<p>以一个基本框架展开。<br>
<strong><a href="http://myTopo.py" target="_blank" rel="noopener">myTopo.py</a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=UTF-8</span></span><br><span class="line"><span class="comment"># a script to create topo</span></span><br><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTopo</span><span class="params">(Topo)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Topo.__init__(self)</span><br><span class="line">        host1 = self.addHost( <span class="string">'h1'</span> )   <span class="comment">#添加主机</span></span><br><span class="line">        host2 = self.addHost( <span class="string">'h2'</span> )</span><br><span class="line">        switch1 = self.addSwitch( <span class="string">'s1'</span> ) <span class="comment">#添加交换机</span></span><br><span class="line">        switch2 = self.addSwitch( <span class="string">'s2'</span> )</span><br><span class="line">        switch3 = self.addSwitch( <span class="string">'s3'</span> )</span><br><span class="line">        self.addLink(host1,switch1,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#添加连接</span></span><br><span class="line">        self.addLink(switch1,switch2,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        self.addLink(switch2,switch3,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        self.addLink(switch3,host2,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">topos = &#123;<span class="string">'mytopo'</span>: <span class="keyword">lambda</span>:MyTopo()&#125;</span><br></pre></td></tr></table></figure>
<p>此脚本生成的是一个字典，字典的键<code>mytopo</code>就是在运行 mininet 的时候输入的参数<code>--topo</code>，这里命名可以自定义。</p>
<p>故在执行这个脚本的时候，<code>mn</code> 后需要的额外添加的参数是：<code>--custom=myTopo.py --topo=mytopo</code><br>
<code>--custom=</code>后面接脚本的目录(+名称)，<code>--topo</code>加入的就是这个字典的键。</p>
<p>字典的值是上面我们动手创建的 mininet.topo 里的 Topo 类的实例的名称，在创建实例对象的时候自定义。</p>
<blockquote>
<p>// 这个lambda没有任何参数迫使我查了一下它的原型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1[, arg2, ... argN]]: expression</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实例的创建，只需要继承 Topo 类，然后在 <code>__init__()</code>方法中写写内容即可。<br>
内容一般包括：初始化，网络设备的创建，网络设备的互联。</p>
<ol>
<li>初始化用的是类方法 <code>Topo.__init__(self)</code></li>
<li>主机和交换机的创建的方法是<br>
<code>self.addHost('hostname')</code>,<code>self.addSwitch('switchname')</code></li>
<li>连接都使用 <code>self.addLink(equipment1, equipment2)</code>，还有一些可选的参数。</li>
</ol>
<p>下面是自己写的一个 Python 脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(Topo)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Topo.__init__(self)</span><br><span class="line">        host1 = self.addHost(<span class="string">"h1"</span>)</span><br><span class="line">        host2 = self.addHost(<span class="string">"h2"</span>)</span><br><span class="line">        host3 = self.addHost(<span class="string">"h3"</span>)</span><br><span class="line">        host4 = self.addHost(<span class="string">"h4"</span>)</span><br><span class="line">        switch0 = self.addSwitch(<span class="string">"s0"</span>)</span><br><span class="line">        switch1 = self.addSwitch(<span class="string">"s1"</span>)</span><br><span class="line">        switch2 = self.addSwitch(<span class="string">"s2"</span>)</span><br><span class="line">        self.addLink(switch0, switch1)</span><br><span class="line">        self.addLink(switch0, switch2)</span><br><span class="line">        self.addLink(switch1, host1)</span><br><span class="line">        self.addLink(switch1, host2)</span><br><span class="line">        self.addLink(switch2, host3)</span><br><span class="line">        self.addLink(switch2, host4)</span><br><span class="line"></span><br><span class="line">topos = &#123;<span class="string">"tree"</span>: <span class="keyword">lambda</span>: Tree()&#125;</span><br></pre></td></tr></table></figure>
<p>在 ODL 里显示如下：<br>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/mytree.png" width="500"></p>
<blockquote>
<p>官方网站：Python mininet<br>
<a href="http://mininet.org/api/annotated.html" target="_blank" rel="noopener">http://mininet.org/api/annotated.html</a></p>
</blockquote>
<h3 id="ODL-v2">ODL</h3>
<p>Mininet 连接 OpenDaylight控制器 的方式就是之前提到的 <code>controller=remote,ip...</code>的方式，<br>
自建复杂的拓扑时，交换机中是没有流表的，使用控制器之后利用其一些组件（Lswitch）其会自动学习与下发流表。<br>
安装的 feature （e.g. Nodes, Topology）有些会体现在网⻚ <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a>:/index.html （ODL所在的系统）上，其实这像服务器。</p>
<h3 id="通过-Wireshark-抓包获取-ODL-和-mininet-的通信信息">通过 Wireshark 抓包获取 ODL 和 mininet 的通信信息</h3>
<h4 id="一图解-OF">一图解 OF</h4>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/一图解OF.png" width="1000">
一些条目的具体信息详见笔记……
<p>这个实验其实很局限，只是通过对 Control 和 OpenFlow 交换机通信抓包，这其实只是 OF 的一个非常小的部分……</p>
<h4 id="实验步骤">实验步骤</h4>
<p>实验步骤也很简单……<br>
先打开 Wireshark 监听Lookback接口（因为我的 ODL 和 mininet 都是在虚拟机里的）<br>
然后建立 ODL 和 mininet 的连接，即可抓到包。<br>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/wireshark_begining.png" width="800"></p>
<p>但是流量包里面还是有很多东西可以探索：<br>
可窥见最开始它们是通过 TCP 协议三次握手连接的。</p>
<p>前三个 OFPT_HELLO 都是相似的，Transaction ID 是递增的。<br>
使用的是 OF 1.4<br>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/OFPT_HELLO.png" width="500/"></p>
<p>接下来是三个 OFPT_HELLO 应该是其中一个发给另一个的，使用的是 OF 1.3<br>
<img src="/2019/11/03/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/OFPT_HELLO2.png" width="500/"></p>
<p>之后进行的是 REQUEST 和 REPLY, 应该在进行各种确认。<br>
同时也发现它们开始统一使用 OF 1.3(这应该是 OFPT_HELLO 的成果)</p>
<p>之后还有各种包(OFPT_PACKET_IN，OFPT_PACKET_OUT)，可惜 OF 这部分理论学习不够，什么时候具体看 OF 协议的时候再回来看看。</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP 欺骗的实现和防御</title>
    <url>/2019/10/26/ARP/</url>
    <content><![CDATA[<h1>VMWare 网络基础知识</h1>
<blockquote>
<p>要进入或离开全屏模式，请按Ctrl+Alt+Enter。<br>
要切换到前一个全屏虚拟机，请按Ctrl+Alt+向左箭头键。<br>
要切换到下一个全屏虚拟机，请按Ctrl+Alt+向右箭头键。</p>
</blockquote>
<h2 id="概览">概览</h2>
<p>虚拟机虚拟了连接的硬件设备（如CD、声卡、打印机等），同时还虚拟了网络配置设备（如 DHCP 服务器，虚拟网络） - VMnet8, VMnet1; VMnet0 虚拟网络。<br>
可以 Windows 系统（主机）控制面板下的 <code>网络和 Internet\网络连接</code> 查看。</p>
<p>VMnet8 - NAT：<br>
<img src="/2019/10/26/ARP/ifconfig_ipconfig.png" width="800"></p>
<h2 id="虚拟机网络配置及原理">虚拟机网络配置及原理</h2>
<p>VMWare提供了三种工作模式：bridged(桥接模式)、NAT(网络地址转换模式)和host-only(主机模式)。</p>
<h3 id="bridged-桥接模式">bridged(桥接模式)</h3>
<p>在桥接模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。<br>
在桥接模式下，你需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。<br>
同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。</p>
<blockquote>
<p>如果你想利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。</p>
</blockquote>
<h3 id="host-only-主机模式">host-only(主机模式)</h3>
<p>在某些特殊的网络调试环境中，要求将真实环境和虚拟环境<strong>隔离</strong>开，这时你就可采用host-only模式。在host-only模式中，所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的。<br>
在host-only模式下，虚拟系统和宿主机器系统是可以相互通信的，相当于这两台机器通过双绞线互连。</p>
<p>在host-only模式下，虚拟系统的 TCP/IP 配置信息(如IP地址、网关地址、DNS服务器等)，都是由 VMnet1(host-only) 虚拟网络的 DHCP 服务器来动态分配的。</p>
<blockquote>
<p>如果想利用VMWare创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作，可以选择host-only模式。</p>
</blockquote>
<h3 id="NAT-网络地址转换模式">NAT(网络地址转换模式)</h3>
<p>使用NAT模式，就是让虚拟系统借助 NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的 TCP/IP 配置信息是由 VMnet8 (NAT) 虚拟网络的 DHCP 服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。</p>
<blockquote>
<p>如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。</p>
</blockquote>
<p>提示:以上所提到的NAT模式下的VMnet8虚拟网络，host-only模式下的VMnet1虚拟网络，以及bridged模式下的VMnet0虚拟网络，都是由VMWare虚拟机自动配置而生成的，不需要用户自行设置。VMnet8和VMnet1提供DHCP服务，VMnet0虚拟网络则不提供(图1)</p>
<p>正常的网络配置有点类似的，如果动态分配的不行，就得手动分配，但是目的不同。</p>
<p>VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。</p>
<h2 id="配置-VMWare-的网络（桥接）">配置 VMWare 的网络（桥接）</h2>
<blockquote>
<p>结合上面的基础知识易得：在实际应用中，桥接的价值还是其中较高的一种。<br>
如果是在利用虚拟机学习新的操作系统的话，桥接其实并不是一种友好的网络配置。如果用 kali 做渗透测试等等的时候，建议使用桥接。</p>
</blockquote>
<h3 id="一个经验">一个经验</h3>
<p>最开始照搬博客的时候出现的问题：“vim中 E212：无法打开并写入文件”<br>
特权模式下都没办法写入数据的可能性：文件夹、文件不存在……<br>
这样出现的问题往往不能通过搜索引擎解决。</p>
<h3 id="补充">补充</h3>
<p>主要参照：<a href="https://blog.csdn.net/gw_csdn/article/details/84992696" target="_blank" rel="noopener">解决kali桥接模式无法上网</a>，这篇写的非常好。<br>
需要补充说明的有：</p>
<ol>
<li>文章中所谓的路由器 IP 就是 网关。（路由器 IP 这样的表示感觉有点偏口语），</li>
<li><code>dhclient</code> 命令使用动态主机配置协议动态的配置网络接口的网络参数。<br>
由于在 <code>/etc/network/interfaces</code> 中，博主配置的是<code>iface lo inet dhcp</code>，也就是动态分配 IP，所以需要用 <code>dhclient</code> 命令进行动态分配。</li>
</ol>
<p>参考多个教程，整体配置逻辑为：</p>
<ol>
<li>VMWare 的虚拟网络编辑器（在菜单栏的编辑下）里更改设置，桥接到对应的端口（如果是无线的，可以接到 Intel®Dual Band Wireless-AC 7265），如果只有一个网卡，自动也没有关系。</li>
<li>对特定的虚拟机的网络适配器进行更改，复制物理网络连接状态有人推荐不要勾选。</li>
<li>以及用命令去对操作系统的网络进行配置，查看方法如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"></span><br><span class="line">root@kali:~<span class="comment"># cat /etc/network/interfaces</span></span><br><span class="line"><span class="comment"># This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="comment"># and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source /etc/network/interfaces.d/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The loopback network interface</span></span><br><span class="line">auto etho</span><br><span class="line">iface lo inet dhcp</span><br><span class="line"></span><br><span class="line">root@kali:~<span class="comment"># dhclient eth0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>APR 欺骗</h1>
<h2 id="ARPSPOOF-攻击实现">ARPSPOOF 攻击实现</h2>
<h3 id="ARP-欺骗简介">ARP 欺骗简介</h3>
<p>APRSPOOF 欺骗：一种中间人攻击，攻击者通过毒化受害者的 ARP 缓存，将网关的MAC 替换成攻击者的MAC ，于是攻击者的主机实际上就充当了受害主机的网关，之后攻击者就可以截获受害者发出和接到的数据包，从中获取账号密码、银行卡信息等，也可以实现断网操作。</p>
<h3 id="攻击前提">攻击前提</h3>
<pre><code>1. 局域网（内网）
2. 内网未进行处理（建议用手机热点或者宿舍wifi 进行操作）
</code></pre>
<p>（使用桥接，一开始使用net 连接操作不成功，可能是net连接中物理机相当于路由器中转数据，虚拟机和主机不在同一个网段）</p>
<p>HP:     113.54.230.118<br>
Kali:   113.54.230.110</p>
<p>想要得到主机的IP可以用kali里面的nmap进行扫描，我们这里为了方便直接打开windows的cmd，输入ipconfig指令得到物理机的ip：<br>
fping指令来扫描当前网段内的所有IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arpspoof -i 网卡 -t B的IP  当前局域网网关</span><br></pre></td></tr></table></figure>
<p>// i-&gt; inet; t -&gt; target<br>
当前网络的端口通过<code>ifconfig</code>查看</p>
<blockquote>
<p>（-i 指定接口 interface ，-t 指定目标 target）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.42.115 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a href="https://www.cnblogs.com/systemnet123/articles/2640883.html" target="_blank" rel="noopener">VMware Network Adapter VMnet1/8详解</a></li>
<li><a href="https://www.cnblogs.com/aeolian/p/8882790.html" target="_blank" rel="noopener">VMWare虚拟机网络配置</a>（图文并茂，讲得很清晰）</li>
<li><a href="https://www.cnblogs.com/systemnet123/articles/2640883.html" target="_blank" rel="noopener">VMware虚拟机Bridged(桥接模式)</a></li>
<li><a href="https://blog.csdn.net/gw_csdn/article/details/84992696" target="_blank" rel="noopener">解决kali桥接模式无法上网</a>(这篇写的非常好)</li>
<li><a href="https://blog.csdn.net/weixin_42578412/article/details/84780401" target="_blank" rel="noopener">使用kali对舍友进行ARP断网攻击</a></li>
<li><a href="https://www.freebuf.com/articles/web/160511.html" target="_blank" rel="noopener">ARP协议分析&amp;python编程实现ARP欺骗抓图片</a></li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>巅峰极客 CoCo Writeup</title>
    <url>/2019/10/20/%E6%9E%81%E5%AE%A2%E5%B7%85%E5%B3%B0-CoCo-writeup/</url>
    <content><![CDATA[<h2 id="CoCo">CoCo</h2>
<h3 id="题目描述">题目描述</h3>
<p>文件：b5574201c88c73ac00b4e5d32b317339_NTURE.zip</p>
<a id="more"></a>
<p><a href="http://challenge.py" target="_blank" rel="noopener">challenge.py</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Random.random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">Co = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">CoCo = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">CoCoCo = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoCoCoCo</span><span class="params">(Co, CoCo)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> CoCo: Co, CoCo = CoCo, Co % CoCo</span><br><span class="line">    <span class="keyword">return</span> Co</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoCoCoCoCo</span><span class="params">(Co, CoCo, CoCoCo)</span>:</span></span><br><span class="line">    CoCoCoCo = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> CoCo != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (CoCo &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            CoCoCoCo = (CoCoCoCo * Co) % CoCoCo</span><br><span class="line">        CoCo &gt;&gt;= <span class="number">1</span></span><br><span class="line">        Co = (Co * Co) % CoCoCo</span><br><span class="line">    <span class="keyword">return</span> CoCoCoCo</span><br><span class="line"></span><br><span class="line">CoCoCoCoCoCoCoCo = CoCoCoCoCo(CoCoCo, Co, CoCo)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    CoCoCoCoCoCoCoCoCo = randint(<span class="number">1</span>, <span class="number">2</span> ** <span class="number">512</span>)</span><br><span class="line">    <span class="keyword">if</span> CoCoCoCo(CoCoCoCoCoCoCoCoCo, CoCo - <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">CoCoCoCoCoCo = bytes_to_long(<span class="string">"CoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCo"</span>)</span><br><span class="line">CoCoCoCoCoCoCoCoCoCo = CoCoCoCoCo(CoCoCo, CoCoCoCoCoCoCoCoCo, CoCo)</span><br><span class="line">CoCoCoCoCoCoCoCoCoCoCo = (CoCoCoCoCoCo * CoCoCoCoCo(CoCoCoCoCoCoCoCo, CoCoCoCoCoCoCoCoCo, CoCo)) % CoCo</span><br><span class="line">CoCoCoCoCoCoCo = bytes_to_long(flag)</span><br><span class="line">CoCoCoCoCoCoCoCoCoCoCoCo = (CoCoCoCoCoCoCo * CoCoCoCoCo(CoCoCoCoCoCoCoCo, CoCoCoCoCoCoCoCoCo, CoCo)) % CoCo</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'cipher.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"CoCoCoCoCoCoCoCoCoCo = "</span> + str(CoCoCoCoCoCoCoCoCoCo) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCoCo = "</span> + str(CoCoCo) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCoCoCoCoCoCoCoCoCoCo = "</span> + str(CoCoCoCoCoCoCoCoCoCoCo) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCo = "</span> + str(CoCo) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCoCoCoCoCoCoCoCoCoCoCo = "</span> + str(CoCoCoCoCoCoCoCoCoCoCoCo) + <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure>
<p>cipher.txt:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoCoCoCoCoCoCoCoCoCo = 112376755434839067242492450580926874835238627566940029196532175644877689078482714802636681537478746972878719135123815462672622666337365766404438579837929587693947036556506459672209528097159093195480318719604062458476883089712408549646871208319887232708573834573129807851612788612229862109446349174773685766921</span><br><span class="line">CoCoCo = 151397348765463697819328127490368915291237595957138740365628078489836085372845681091989345334904026246892900348971981402476845038743843701086311667536372419728644485998870855126715225674611022660290971207449534822797616008980284083777280866124762176520095351401654370256535990768524594118090702757650148363921</span><br><span class="line">CoCoCoCoCoCoCoCoCoCoCo = 120085813769601903784459580746767828105716607333492124010803514777437504109331448009890874939858984666641139819379969714070220763093188551966830630639308142299719976258227450642141963425187429636880593480951498406380068747404115889400485463839002674872020074254287490910994729347868122864760194135575038263365</span><br><span class="line">CoCo = 133694097868622092961596455982173439482901807533684907590429464542321832157724052684517499871073826858762297729480414306161113412741865099163152505447334863097434932940729269605986418443532208942119505043634990271717198694190123478547503837269948205839761848366722796091382894026537012764323367229104988051357</span><br><span class="line">CoCoCoCoCoCoCoCoCoCoCoCo = 53913320010474614353771348695262553935361078517742942745359182152882204780769206005474818637010209561420480280523029509375286538886061621596249179407728697515399046471231513536340506648832858695583318765423245104561512700887050932667507358898646356134386213016528778706360147066411877832628237361011621917972</span><br></pre></td></tr></table></figure>
<h3 id="分析与解">分析与解</h3>
<h4 id="Coco">Coco</h4>
<p>变量的命名丧心病狂……<br>
姑且用数目代替原来的名字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. CoCoCo -&gt; three</span><br><span class="line">    CoCoCoCoCoCo -&gt; twelve</span><br></pre></td></tr></table></figure>
<p>由于数容易数错，替换也会因为短的是长的前缀，所以不能一键替换，也要仔细数。<br>
当然用 Python <code>len()/2</code> + <code>复制</code> 更好。</p>
<blockquote>
<p>题目用这种方式主要目的可能还是为了掩盖变量对应的含义。</p>
</blockquote>
<h4 id="函数理解">函数理解</h4>
<p>代码中有两个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoCoCoCo</span><span class="params">(one, two)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> two: one, two = two, one % two</span><br><span class="line">    <span class="keyword">return</span> one</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoCoCoCoCo</span><span class="params">(one, two, three)</span>:</span></span><br><span class="line">    four = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> two != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (two &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            four = (four * one) % three</span><br><span class="line">        two &gt;&gt;= <span class="number">1</span></span><br><span class="line">        one = (one * one) % three</span><br><span class="line">    <span class="keyword">return</span> four</span><br></pre></td></tr></table></figure>
<p>第一个函数一眼就可以看出来是欧几里得算法。<br>
<code>two: one, two = two, one % two</code>是欧几里得算法的理论基础。<br>
第二个看得很熟悉，但是当时没有立刻搞懂……（导致后面的理解很受挫……）</p>
<blockquote>
<p><code>&gt;&gt;=</code> 是向右移位一位，但是操作数只能是整数（所以相当于除以2，小数部分直接舍去）</p>
</blockquote>
<p>回头看的时候想起来是当时 ACM 上的<a href="https://blog.csdn.net/qq_32680617/article/details/50640622" target="_blank" rel="noopener">快速求幂取模</a>……</p>
<blockquote>
<p>为了增加代码可读性，我们用 <code>gmpy2.gcd(a,b)</code> 代替 <code> CoCoCoCo(Co, CoCo)</code>；用 <code>pow(a, b, n) </code> 代替 <code>CoCoCoCoCo(Co, CoCo, CoCoCo)</code>。<br>
最后需要深刻反思…… ACMer 的优势。这周开始刷数论的算法题，看《算法竞赛入门》的数量部分</p>
</blockquote>
<h4 id="分析和调整代码">分析和调整代码</h4>
<p>知道了函数的作用（尤其发现和数论直接相关），整个代码的基本功能就能很好地理解。<br>
但是代码的毛病不止是变量的命名，还有顺序：函数放在中间是什么意思？？？+一些代码调换位置会更容易看懂。<br>
此外，刚刚也说了只是姑且用数目代替原来的名字……<br>
需要根据代码的意义去分析，基本分析完成后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Random.random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">a = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">p = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">c = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment"># get a number(n) enable (n-1, random-e) = 1</span></span><br><span class="line">    e = randint(<span class="number">1</span>, <span class="number">2</span> ** <span class="number">512</span>) <span class="comment"># 1- 2 ** 512 之间</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.gcd(e, p - <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">eight = pow(c, a, p)</span><br><span class="line">ten = pow(c, e, p)</span><br><span class="line"></span><br><span class="line">six = bytes_to_long(<span class="string">b"CoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCo"</span>)</span><br><span class="line">seven = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">eleven = (six * pow(eight, e, p)) % p</span><br><span class="line">twelve = (seven * pow(eight, e, p)) % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'cipher.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f: <span class="comment"># 写进文件</span></span><br><span class="line">    f.write(<span class="string">"CoCoCoCoCoCoCoCoCoCo = "</span> + str(ten) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCoCo = "</span> + str(c) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCoCoCoCoCoCoCoCoCoCo = "</span> + str(eleven) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCo = "</span> + str(p) + <span class="string">"\n"</span>)</span><br><span class="line">    f.write(<span class="string">"CoCoCoCoCoCoCoCoCoCoCoCo = "</span> + str(twelve) + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># two - p</span></span><br><span class="line"><span class="comment"># (e, n - 1) == 1</span></span><br><span class="line"><span class="comment"># three - c</span></span><br><span class="line"><span class="comment"># one - a</span></span><br><span class="line"><span class="comment"># nine - e</span></span><br></pre></td></tr></table></figure>
<p>确实是一个浩大的工程……（一共十二个变量）<br>
做了多次调整…… Orz<br>
其中印象很深的是 p:<br>
在 RSA 的模数一般是 n，所以会想当然地把最后定为 p 的变量（CoCo）最开始当成 n。<br>
但是一直让我费解的是：<code>gmpy2.gcd(e, CoCo - 1) == 1;</code></p>
<p>$\because (e, \varphi (m))=1 $ 而 $ \varphi (m) = \varphi (pq) = (p-1)(q-1)$<br>
$\therefore (e, (p-1))=1$</p>
<p>基于这一点，所以我就猜想 CoCo 其实不是 n，而是 p。</p>
<h4 id="数学分析">数学分析</h4>
<p>这道题更像是自己设计的加密算法，所以纯粹靠自己进行数学分析。</p>
<h5 id="条件：">条件：</h5>
<p>（黄色表示最终目标，蓝色表示已知条件，灰色表示关键的中间变量）</p>
<img src="/2019/10/20/%E6%9E%81%E5%AE%A2%E5%B7%85%E5%B3%B0-CoCo-writeup/CoCodraft.png" width="600/">
<h5 id="灵感和正解">灵感和正解</h5>
<p>记得之前一道奇妙的“数学题”条件没有用完一直让我耿耿于怀，这次碰巧看到一个博客是讲那道题目的：<br>
<a href="http://blog.cirq.me/2018/02/07/Codegate2018-rsababy/" target="_blank" rel="noopener">Codegate CTF 2018 - RSAbaby</a><br>
其中一句话点醒了我：“真正的 crypter 对于题目的直觉令人十分惊异：h参数看起来太奇怪了，所以直接无视它！看到这里也只能怪自己的高考思维了，毕竟现实世界中，不是每一个条件都是有用的嘛。”<br>
于是猛回头解题，重新审视。</p>
<p>开始集中关注后面两个式子：</p>
<ol>
<li>$ tweleve = seven \times eight^e  \pmod p $</li>
<li>$ eleven = six \times eight^e \pmod p$<br>
其实他们是两个同余方程。</li>
</ol>
<p>如果！<br>
把  $eight^e$ 看成一个整体，而不是想要求出 $eight^e$，角度完全不同。<br>
复杂的式子变得极度简单，不妨设 $x = (eight^e , mod ,p)$.</p>
<ol>
<li>$ tweleve = seven \cdot x \pmod p $</li>
<li>$ eleven = six \cdot x \pmod p $</li>
</ol>
<p>变成两个同余方程。<br>
其中第二个式子只有一个未知变量x，求出来之后第一个式子也就变成一元一次的同余方程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Random.random <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">six = bytes_to_long(<span class="string">b"CoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCoCo"</span>)</span><br><span class="line">eleven = <span class="number">120085813769601903784459580746767828105716607333492124010803514777437504109331448009890874939858984666641139819379969714070220763093188551966830630639308142299719976258227450642141963425187429636880593480951498406380068747404115889400485463839002674872020074254287490910994729347868122864760194135575038263365</span></span><br><span class="line">tweleve = <span class="number">53913320010474614353771348695262553935361078517742942745359182152882204780769206005474818637010209561420480280523029509375286538886061621596249179407728697515399046471231513536340506648832858695583318765423245104561512700887050932667507358898646356134386213016528778706360147066411877832628237361011621917972</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">133694097868622092961596455982173439482901807533684907590429464542321832157724052684517499871073826858762297729480414306161113412741865099163152505447334863097434932940729269605986418443532208942119505043634990271717198694190123478547503837269948205839761848366722796091382894026537012764323367229104988051357</span></span><br><span class="line">x = gmpy2.invert(gmpy2.mpz(six), gmpy2.mpz(p)) * gmpy2.mpz(eleven)</span><br><span class="line">tweleve= gmpy2.invert(gmpy2.mpz(x), gmpy2.mpz(p)) *gmpy2.mpz(tweleve)</span><br><span class="line">tweleve %= p</span><br><span class="line">flag  = long_to_bytes(tweleve)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>b’flag{394191c7-261c-4ecb-a1bd-a6440639f217}’</p>
</blockquote>
<p>需要注意的是： invert() 这个函数返回的值不是那么理想，没有注意到这一点的我，第一次解出的 flag 很奇怪：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&quot;#&amp;\xd1?_T\xdd\xb1!\x11\x00`V\rI&#123;\xb0\t\x8eW=&lt;z\xfeq\x1f\xfa\xca\xfd\x93mx\xe71\x0f\xa2\x1fD\x06H/&#125;\xe1_\x1b\x87+\xa1\xb0\xcb\xe6\xfa\r\xdbt\xa6\x95g&apos;x\xe2\x0b\xa2.\x08N\xcc\xa3\xd1\xba\x82\xa2,\xdeW1\x1b\x8e\x88\x97\xde\xf5E\x8a\xf1r\xedU\x9e\xe1\xb6\xc0\x1d\xc1\x85\x1b\x96J\x9bJm&#125;\xb0\x9a\xc5\x04\x9b\x1duo\x11&amp;7\xa0U\x96\xb1h\xe7\x1d8rwY8v\x92\xd9:\x9e6\xd9\xb0\xea.\xe0\x89\xd0|\xfd\xf6\x96Tg\x87\xaew\x9eH!\x87\xb7\xd6\x1d\xcf/&amp;E\xae\x056hd\xe2\xbd\x81&#123;\xc1(P\xd1\x14?\x13(r\xd0D\x1d\xfe$\xf6z&#125;\x82u\xf2F#\xdb-\x18\xce\x94\xf2\x87\xfd\x86\xe3 \\\x87\x8b\xf12:p\xea\x02b\x05\xe6L)\xbd&lt;,\x15\x89\xc6I\xde\x96B\xf5\xda&gt;`\x15rC\xeed\xb1&#123;\xf9\xba&apos;y\xb0Wv(z\xa8\x95?\xa9J\x10\x06s#\xca\x89\xd0&quot;</span><br></pre></td></tr></table></figure>
<p>但是带回去验算又没有问题。<br>
通过对比的对 six 进行 <code>bytes_to_long</code> 和 <code>long_to_bytes</code> 实验，发现 flag 比 six 大非常非常多……<br>
所以才想是 invert() 的问题， 所以再 <code>tweleve %= p</code> 了一遍，然后转回字符串，终于成功。<br>
在比赛结束前三十多米秒提交。</p>
<h3 id="题目特点">题目特点</h3>
<ol>
<li>用恶心的变量名去掩盖变量真实的含义</li>
<li>不是特殊的加密算法，是自己编造的加密方法，没有资料和经验，完全依靠数学和想象力。</li>
</ol>
<h2 id="赛后官方-WP">赛后官方 WP</h2>
<p>赛后仔细看了官方的 WP，并推算了一遍，发现他的费马小定理用得画蛇添足，思路也不怎么清晰，如果展开推算，最后又会绕回来，最后的最后形式是和我的推算相一致。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
  </entry>
  <entry>
    <title>招新：Crypto方向介绍</title>
    <url>/2019/10/10/CTF-Crypto%20%E6%96%B9%E5%90%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1>Crypto 方向基础</h1>
<h2 id="入门基础">入门基础:</h2>
<ol>
<li>C语言<br>
// 很多代码审计都是以 C语言形式呈现</li>
<li>Python3:
<ol>
<li><a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">廖雪峰的博客</a></li>
<li>gmpy2库、Crypto库的使用</li>
</ol>
</li>
<li><strong>数学基础</strong> (重中之重)<br>
可以参考《信息安全数学基础》（初等数论、近世代数）</li>
<li>linux的常见使用<br>
基础密码学最重要的是要能在 Linux 系统下运行脚本、使用工具。<br>
其余的遇到问题看需要再去学。</li>
</ol>
<a id="more"></a>
<p>注意事项：</p>
<blockquote>
<ol>
<li>密码学的要求是两点：算法编程能力，数学推理能力。</li>
<li>在很多人看来，没有 pwn、Web 这些能做大量攻击的方向有趣，因人而异吧。</li>
<li>密码学基础学完之后会有很多和其他方向（Web, misc, pwn, re）交汇的地方。<br>
参见题目：<br>
DEF CON CTF Qualifier 2018 SAG?<br>
DEF CON CTF Qualifier 2018 smcauth<br>
DEF CON CTF Qualifier 2018 Easy Pisy<br>
codegate2018 miro</li>
</ol>
</blockquote>
<h2 id="涵盖基本知识">涵盖基本知识</h2>
<ol>
<li>常见编码方式<br>
base家族、Uuencode、Xxencode 等等等等。</li>
<li>古典密码<br>
凯撒密码、栅栏密码、维基利亚密码 等等等等。</li>
<li>分组密码<br>
DES、AES 等。</li>
<li>非对称密码<br>
RSA、Elgamal、ECC等。</li>
<li>哈希函数<br>
经常出现在 Web 题目中</li>
</ol>
<h2 id="资源推荐">资源推荐</h2>
<ol>
<li>学习方式推荐：<br>
看书+看ctfwiki或者自己找一些blog+做题</li>
<li>密码学书籍：<br>
《信息安全数学基础》（各个学校都有自己的版本）<br>
<a href="https://item.jd.com/11103297.html" target="_blank" rel="noopener">《深入浅出密码学：常用加密技术原理与应用》</a></li>
<li>密码学学习网站推荐：<br>
<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/introduction/" target="_blank" rel="noopener">Wiki-CTF-Crypto</a><br>
（主要是面向ctf解题以及算法编程）</li>
<li>做题网站：<br>
<a href="https://adworld.xctf.org.cn/" target="_blank" rel="noopener">https://adworld.xctf.org.cn/</a><br>
<a href="https://github.com/ctfs/write-ups-2017" target="_blank" rel="noopener">https://github.com/ctfs/write-ups-2017</a></li>
</ol>
<h2 id="题目类型">题目类型</h2>
<table>
<thead>
<tr>
<th>攻击方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>唯密文攻击</td>
<td>只拥有密文</td>
</tr>
<tr>
<td>选择明文攻击</td>
<td>拥有加密权限，能够对明文加密后获得相应密文</td>
</tr>
<tr>
<td>已知明文攻击</td>
<td>拥有密文与对应的明文。</td>
</tr>
<tr>
<td>选择密文攻击</td>
<td>拥有解密权限，能够对密文解密后获得相应明文</td>
</tr>
</tbody>
</table>
<p>Crypto 方向负责人：ZER0-Nu1L</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL</title>
    <url>/2019/09/29/OpenSSL/</url>
    <content><![CDATA[<h1>openssl 简介</h1>
<p>openssl是web安全通信的基石</p>
<h2 id="基础知识">基础知识</h2>
<h3 id="SSL">SSL</h3>
<p>Secure Socket Layer(安全套接字层)<br>
主要是防止信息在互联网上传输的时候不被窃听或者篡改</p>
<h3 id="数字签名">数字签名</h3>
<p>将报文使用一定的 HASH 算法算出一个固定位数的摘要信息，然后用私钥将摘要加密，连同原来的报文一起，发送给接收者。<br>
接受者通过公钥将摘要解出来，再通过 HASH 算法算出报文摘要，对比两者。<br>
如果两个摘要一致，说明数据未被篡改，数据是完整的。</p>
<blockquote>
<p>数字签名具有证明发送者身份和防篡改的功能。</p>
</blockquote>
<a id="more"></a>
<h3 id="数字证书">数字证书</h3>
<p>由CA颁发给网站的身份证书，里面包含了该网站的公钥，有效时间，网站的地址，CA的数字签名等。</p>
<p>手动查看方式：<br>
<image src="./证书.png" width="300"><br>
<image src="./Web证书入口.png" width="300"></image></image></p>
<p>实际上就是使用了CA的私钥将网站的公钥等信息进行了签名，当客户端请求服务器的时候，网站会把证书发给客户端，客户端首先可以通过CA的数字签名校验CA的身份，也能证明证书的真实完整性<br>
CA的地址是内嵌在浏览器中的，很难被篡改。</p>
<h2 id="SSL如何保护数据">SSL如何保护数据</h2>
<p>1）认证用户和服务器，确保数据发送到正确的客户端和服务器；<br>
2）加密数据以防止数据中途被窃取；<br>
3）维护数据的完整性，确保数据在传输过程中不被改变。</p>
<h3 id="认证用户和服务器">认证用户和服务器</h3>
<blockquote>
<p>怎么知道自己访问的是真百度还是假百度？是不是有可能有人<strong>劫持</strong>了我们访问百度的请求，然后路由给了一台他伪造的服务器？</p>
</blockquote>
<p>在SSL的通信流程中做了这样一个规定：一旦我们向服务器发送了请求后，服务器必须返回它的数字证书，当我们拿到数字证书之后，我们可以根据里面的ca数字签名，校验证书的合法性（不是被伪造的）</p>
<p>假设百度服务器是假冒的，他一定没有正确的私钥，那么之后的通信都无法进行，所以假冒服务器是无法操作的。</p>
<p>由此，SSL就解决了服务器认证的问题。</p>
<h3 id="加密数据以防止数据中途被窃取">加密数据以防止数据中途被窃取</h3>
<p>客户端第一次给服务器发送请求的时候（拿到证书前的一次），会在请求里面放一个随机数C1；<br>
服务器在返回证书的响应里也会带一个随机数F；<br>
客户端拿到证书后，会使用公钥加密一个随机数C2送给服务器。<br>
这样客户端、服务器都拥有了三个随机数：C1、F、C2。<br>
双方使用<strong>这些</strong>随机数和一个相同的算法生成一个对称密钥，之后所有的通信都使用这个对称密钥来进行。</p>
<p>这个密钥会不会被泄露呢？不会，因为密钥是由3个随机数产生的，对于第一个随机数C1，他可能会被中间人监听到，然后第二个随机数F，也可能会被中间人监听到，但是第三个随机数C2，因为是用公钥加密的，除非中间人有私钥，否则是不可能解出来的。</p>
<h3 id="维护数据的完整性">维护数据的完整性</h3>
<p>针对服务器发送数字证书这一过程来说，<br>
服务器的数字证书中含有ca数字签名，可以很有效的保证证书的真实性和完整性（没有被篡改）</p>
<h2 id="openssl">openssl</h2>
<p><s>参考：<a href="https://segmentfault.com/a/1190000014963014" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014963014</a></s><br>
参考：<a href="E:/%60Desktop/eBook/Cryptology/OpenSSL%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-%E5%9F%BA%E7%A1%80%E3%80%81%E7%BB%93%E6%9E%84%E5%92%8C%E6%8C%87%E4%BB%A4.pdf" target="_blank" rel="noopener">《OpenSSL与网络信息安全-基础、结构和指令》</a><br>
//博客资料太少</p>
<p>SSL只是一个协议，openssl则是SSL的实现版<br>
openssl还包含了公钥私钥的生成、摘要生成等各种工具。</p>
<h4 id="生成-RSA-密钥-genrsa-指令">生成 RSA 密钥 - genrsa 指令</h4>
<image src="openssl_genrsa.png" width="700/">
<ul>
<li>RSA 最重要的就是私钥的保密性，所以会用对称加密再对私钥加密</li>
<li>对于 OpenSSL 来说，文件名和其后缀都是没有特别含义的，你可以取任意名字，当然，习惯的用法是以格式来指令后缀，比如 “pem”。</li>
<li>注意参数的顺序，加密类型可以放在口令之前，位长建议放在最后。</li>
</ul>
<p>举例：<br>
生成一个 1024 位的 RSA 密钥，并输出到 rsaprivkey.pem 文件中.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL&gt;genrsa -out rsaprivkey.pem 1024</span><br></pre></td></tr></table></figure>
<p>生成一个 1024 位的 RSA 密钥，并采用 DES3 算法进行加密, 并输出到 &gt; rsaprivkey.pem 文件中.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL&gt;genrsa -out rsaprivkey.pem -des3 -passout pass:xY*&amp;2wG</span><br></pre></td></tr></table></figure>
<p>(外接硬件设备的例子略)</p>
<h4 id="管理-RSA-密钥-genrsa-指令">管理 RSA 密钥 - genrsa 指令</h4>
<image src="openssl_rsa.png" width="800/">
<ul>
<li>功能一：对私钥加密/更改对私钥加密的方式（公钥加密无意义）/去掉加密</li>
<li>功能二：明文输出文件中保存的内容</li>
</ul>
<p>举例：<br>
将一个加密的 PEM 编码的 RSA 私钥(privkey.pem ) 转换成一个不加密的 PEM 编码的 RSA 私钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL&gt;rsa -in privkey.pem -passin pass:1234567 -out privkey.pem</span><br></pre></td></tr></table></figure>
<p>原来使用 DES3 加密的 RSA 私钥保存不够安全，而想要使用 256 位 AES 算法加密的时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL&gt;rsa -in privkey.pem -passin pass1234567 -passout xY*&amp;2wG -aes256</span><br></pre></td></tr></table></figure>
<p>对于明文输出文件保存内容的例子并不令人满意……</p>
<p>Normal_RSA 题解里面的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl&gt;rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br></pre></td></tr></table></figure>
<p>不知道他怎么弄出来的，就连在《openssl-cookbook》也没找到其中的一些参数。</p>
<hr>
<p>参看：<a href="https://www.jianshu.com/p/bb2f50862025" target="_blank" rel="noopener">https://www.jianshu.com/p/bb2f50862025</a></p>
<p>简单地生成私钥 d :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl&gt; genrsa -out private.pem 1024</span><br><span class="line">// -out 输出文件 ； 1024 表示位数</span><br></pre></td></tr></table></figure>
<p>提取公钥 e :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl&gt; rsa -in private.pem -pubout -out public.pem</span><br><span class="line">// -in 输入文件，这里是使用私钥；</span><br><span class="line">//-pubout 输出公钥文件</span><br><span class="line">//-out 输出，后跟目标文件</span><br></pre></td></tr></table></figure>
<p>对明文进行加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl&gt; rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt</span><br><span class="line">// -encrpt 加密模式</span><br><span class="line">// -in 输入文件，此时是明文</span><br><span class="line">// -inkey 输入公钥</span><br><span class="line">// -pubin 将公钥放进文件？</span><br><span class="line">// -out 输出文件</span><br></pre></td></tr></table></figure>
<p>对明文进行解密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl&gt; rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt</span><br><span class="line">// -decrpt 解密模式</span><br><span class="line">// -in 输入文件，此时是密文</span><br><span class="line">// -inkey 输入私钥</span><br><span class="line">// -out 输出文件</span><br></pre></td></tr></table></figure></image></image>]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界新手区 writeup</title>
    <url>/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/</url>
    <content><![CDATA[<h2 id="Write-up">Write up</h2>
<h3 id="0x01-base64">0x01 base64</h3>
<h4 id="题目说明">题目说明</h4>
<p>元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。</p>
<a id="more"></a>
<p>附件：base64-crypto1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9</span><br></pre></td></tr></table></figure>
<h4 id="分析">分析</h4>
<p>base64 应该是编码，算不上加密。</p>
<h5 id="Python-base64-内建模块">Python base64 内建模块</h5>
<p>参考：<a href="https://blog.csdn.net/zyz511919766/article/details/22681399" target="_blank" rel="noopener">Python base64模块详解</a></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>urlsafe_b64encode, urlsafe_b64decode</td>
<td>专门对url进行base64编解码的，实际上也是调用的前一组函数。</td>
</tr>
<tr>
<td>encode, decode</td>
<td>编码和解码文件,对 StringIO 里的数据做编解码 (StringIO是从内存中读写str)</td>
</tr>
<tr>
<td><s>encodestring, decodestring</s></td>
<td>编码和解码字符串，但是在 Python 3.1 之后这个名字被弃用</td>
</tr>
<tr>
<td>encodebytes, decodebytes</td>
<td>编码和解码字符串，代替 encodestring, decodestring</td>
</tr>
<tr>
<td><strong>b64encode, b64decode</strong></td>
<td>编码和解码字符串，并且有一个替换符号字符的功能</td>
</tr>
</tbody>
</table>
<p>我们最常用的是 b64encode, b64decode，当然某些情况用 encodebytes, decodebytes 也没有大碍。</p>
<p><strong>注意:</strong> encodebytes, decodebytes, b64encode, b64decode 都是对二进制字符串加解码.<br>
e.g. <code>b'liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3J'</code></p>
<blockquote>
<p>由于base64编码后的字符除了英文字母和数字外还有三个字符 <code>+</code>, <code>/</code>, <code>=</code>,<br>
其中<code>=</code>只是为了补全编码后的字符数为4的整数，而<code>+</code>和<code>/</code>在一些情况下需要被替换的，<br>
b64encode和b64decode正是提供了这样的功能。<br>
<code>+</code>和<code>/</code>需要被替换，把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>,最常见的就是对 url 进行 base64 编码的时候。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line">str1 = <span class="string">b'djhui'</span></span><br><span class="line">str2 = base64.b64encode(str1)</span><br><span class="line">str3 = base64.b64decode(str2)</span><br><span class="line">str4 = base64.encodebytes(str1)</span><br><span class="line">str5 = base64.decodebytes(str4)</span><br><span class="line">print(str2)</span><br><span class="line">print(str3)</span><br><span class="line">print(str4)</span><br><span class="line">print(str5)</span><br></pre></td></tr></table></figure>
<h4 id="题解">题解</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher = <span class="string">b'Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9'</span></span><br><span class="line">print(base64.b64decode(cipher))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x02-Caesar">0x02 Caesar</h3>
<h4 id="题目说明-v2">题目说明</h4>
<p>你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了</p>
<p>附件：Caeser-crypto2.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题解-v2">题解</h4>
<p><a href="https://planetcalc.com/1434/#" target="_blank" rel="noopener">https://planetcalc.com/1434/#</a> 直接分析出来<br>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/Caesar.png" alt></p>
<hr>
<h3 id="0x03-Morse">0x03 Morse</h3>
<h4 id="题目说明-v3">题目说明</h4>
<p>题目描述：小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写)</p>
<p>附件：Morse-crypto3.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110</span><br></pre></td></tr></table></figure>
<p>摩斯密码使用 <code>.</code>、<code>-</code> 来表示不同含义，这里只用 <code>0</code>和<code>1</code>，所以应该是用<code>01</code>代替<code>.</code>、<code>-</code>。<br>
那么到底是用<code>1</code>代表<code>.</code>还是用<code>0</code>代表<code>.</code>呢？<br>
都试一下不就好了……</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用·表示0，-表示0</span><br><span class="line">11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110</span><br><span class="line">m  o   r   s   e c    o   d   e i  s   s   o   i  n  t e r   e s   t i  n  g</span><br><span class="line">-&gt;  morsecodeissointeresting</span><br><span class="line">cyberpeace&#123;morsecodeissointeresting&#125;</span><br></pre></td></tr></table></figure>
<p><strong>个人思考：</strong></p>
<blockquote>
<p>Morse 编码能用两个符号就能表示26个字母和十个数字，并且不会产生歧义，一定有它的方法。稍微想一下，其实就能想到这个方法，就是用哈夫曼编码。<br>
用<code>.</code>表示左分支，用<code>-</code>表示右分支。<br>
根结点没有数据，第二层左孩子和右孩子分别是<code>.</code>和<code>-</code>.<br>
有：$2<sup>5-2&lt;26+10&lt;2</sup>6-2$ .<br>
所以对应的树的深度是 5，亲测正确（手画）。</p>
</blockquote>
<hr>
<h3 id="0x04-Railfence">0x04 Railfence</h3>
<h4 id="题目描述">题目描述</h4>
<p>被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的 图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。</p>
<p>附件：Railfence-crypto4.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g</span><br></pre></td></tr></table></figure>
<h4 id="分析-v2">分析</h4>
<h5 id="常规思路">常规思路</h5>
<p>len = 35<br>
尝试用栅栏密码解密<br>
在线工具：<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a><br>
但是尝试无果？？！！！<br>
手动分析，利用前几个字母已知(cyberpeace{.+})的条件分析了半天，无果。</p>
<h5 id="重新审视">重新审视</h5>
<p>这个不是普通的栅栏密码！<br>
终于在某个博客上看到了线索：<br>
<a href="https://blog.csdn.net/qinying001/article/details/96134356" target="_blank" rel="noopener">栅栏密码的变种WWW型</a></p>
<h5 id="栅栏密码的变种WWW型">栅栏密码的变种WWW型</h5>
<p>传统型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如有一个字符串：123456789</span><br><span class="line">取字符串长度的因数进行分组，假如key=3</span><br><span class="line">1 2 3  \\分组情况，每三个数字一组，分为三组</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">然后每一组依次取一个数字组成一个新字符串：147258369 \\加密完成的字符串</span><br></pre></td></tr></table></figure>
<p>WWW型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同样一个字符串：123456789</span><br><span class="line">key=3</span><br><span class="line">1----5----9  \\让数字以W型组织，同样是三组，但每组的数量不一定相同</span><br><span class="line">-2--4-6--8</span><br><span class="line">--3----7--</span><br><span class="line">加密密文：159246837</span><br></pre></td></tr></table></figure>
<h4 id="题解-v3">题解</h4>
<p>可以用脚本（见<code>E:\·桌面\Cryptology\古典密码学\移位密码</code>）<br>
也可以用工具：<a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=777</a> （默认 WWW 型加解密）</p>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/Railfence.png" width="500">
<hr>
<h3 id="0x07-不仅仅是Morse">0x07 不仅仅是Morse</h3>
<h4 id="题目描述-v2">题目描述</h4>
<p>“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”</p>
<p>附件：Railfence-crypto4.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.-</span><br></pre></td></tr></table></figure>
<h4 id="分析-题解">分析+题解</h4>
<p>是摩斯密码的形式，先对摩斯密码解码。<br>
<strong>工具</strong>：<a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="noopener">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a><br>
（这个网站对摩斯代码的分隔方式支持单斜杠和空格，比较好）<br>
<strong>返回结果</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAYBEHAVEANOTHERDECODEHHHHAAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA</span><br></pre></td></tr></table></figure>
<p>Maybe have another decode …<br>
它的意思应该不是让你从头开始换另一个，而是对摩斯密码解析出来的再用一个的方式解密。<br>
此刻应该关注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA</span><br></pre></td></tr></table></figure>
<p>很有特征的是，它只有两个字符组成，这是培根密码的典型特征。（手抓饼，A套餐，B套餐）<br>
工具：<a href="http://rumkin.com/tools/cipher/baconian.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/baconian.php</a></p>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/不只是Morse.png" width="500">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyberpeace&#123;ATTACKANDDEFENCEWORLDISINTERESTING&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x08-混合编码">0x08 混合编码</h3>
<h4 id="题目描述-v3">题目描述</h4>
<p>经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。</p>
<p>附件：Railfence-crypto4.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow==</span><br></pre></td></tr></table></figure>
<h4 id="分析-v3">分析</h4>
<h5 id="base64">base64</h5>
<p>以<code>==</code>结尾，应该是base家族。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher = <span class="string">b'JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiM  xMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow=='</span></span><br><span class="line">print(base64.b64decode(cipher))</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&apos;LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw&apos;</span><br></pre></td></tr></table></figure>
<p>这一串组成主要是’A-Z, a-z, 0-9’，还是 base64.</p>
<h5 id="还是base64">还是base64</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher = <span class="string">b'LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw'</span></span><br><span class="line">print(base64.b64decode(cipher))</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&apos;/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100&apos;</span><br></pre></td></tr></table></figure>
<p>应该是 ASCII 码</p>
<h5 id="ASCII-码">ASCII 码</h5>
<p>工具：<a href="http://www.ab126.com/goju/1711.html" target="_blank" rel="noopener">http://www.ab126.com/goju/1711.html</a><br>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/混合编码.png" width="500"></p>
<p>也可以用 Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher_1=<span class="string">b'LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw'</span></span><br><span class="line">plain_1 = base64.b64decode(cipher_1).decode() <span class="comment"># byte -&gt; string</span></span><br><span class="line">plain_1 = plain_1.strip(<span class="string">'/'</span>)</span><br><span class="line">lst2, cipherlst2 = [], []</span><br><span class="line">cipherlst2 = list(map(int, plain_1.split(<span class="string">'/'</span>)))</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> cipherlst2:</span><br><span class="line">    lst2.append(chr(num))</span><br><span class="line">plaintext = <span class="string">""</span>.join(lst2)</span><br><span class="line">print(plaintext)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyberpeace&#123;welcometoattackanddefenceworld&#125;</span><br></pre></td></tr></table></figure>
<h5 id="意外情况——环境相关？-Unicode">意外情况——环境相关？ - Unicode</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher = <span class="string">b'JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiM  xMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow=='</span></span><br><span class="line">print(base64.decodebytes(cipher))</span><br></pre></td></tr></table></figure>
<p>这段代码在 Markdown 里面运行能直接得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw&apos;</span><br></pre></td></tr></table></figure>
<p>但是在我的 Python 中运行的结果却是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119&apos;</span><br></pre></td></tr></table></figure>
<p>看了其他人的 write up，有些只有两次 base64，有些和我的情况一样。<br>
那怎么处理？<br>
显然这是 Unicode 编码<br>
工具：<a href="https://tool.chinaz.com/Tools/unicode.aspx" target="_blank" rel="noopener">https://tool.chinaz.com/Tools/unicode.aspx</a><br>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A0%81-Unicode.png" alt><br>
之后的步骤同上。<br>
可以用 Python<br>
Unicode 的 &amp;# 形式后面跟的数字和 ASCII 码 在数字区和字母区应该是重合的。<br>
所以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher_num_str = <span class="string">'&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119'</span></span><br><span class="line">cipher_num_str = cipher_num_str.replace(<span class="string">"&amp;#"</span>, <span class="string">""</span>)</span><br><span class="line">lst = []</span><br><span class="line">cipher_list = list(map(int, cipher_num_str.split(<span class="string">';'</span>)))</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> cipher_list:</span><br><span class="line">    lst.append(chr(num))</span><br><span class="line">plaintext_maybe = <span class="string">""</span>.join(lst)</span><br><span class="line">print(plaintext_maybe)</span><br></pre></td></tr></table></figure>
<h4 id="Python-补充">Python 补充</h4>
<blockquote>
<p>编码不在 Crypto 的 Wiki 中，所以这道题做得比较艰难；Python的重要的一些函数也有些忘了，这里做补充。</p>
</blockquote>
<h5 id="map函数">map函数</h5>
<p>参考：<a href="https://www.runoob.com/python/python-func-map.html" target="_blank" rel="noopener">菜鸟教程 Python map() 函数</a></p>
<h6 id="描述">描述</h6>
<p>是种映射(map)函数，可以对列表每个元素进行操作（映射/函数）</p>
<h6 id="语法">语法</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure>
<p>iterable: 一个或多个序列<br>
Python 2.x 返回列表。<br>
Python 3.x 返回迭代器。</p>
<h6 id="用法">用法</h6>
<figure class="highlight python"><figcaption><span>&#123;cmd .line-nubmers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">lst = list( map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) )</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>
<h6 id="将列表中的字符串转为数字">将列表中的字符串转为数字</h6>
<figure class="highlight python"><figcaption><span>&#123;cmd .line-nubmers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line">numbers = [<span class="string">'1'</span>,<span class="string">'124'</span>, <span class="string">'6982'</span>, <span class="string">'320'</span>]</span><br><span class="line">lst = list( map(int, numbers) )</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>
<h5 id="bytes、str函数">bytes、str函数</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bytes object</span></span><br><span class="line">b = <span class="string">b"example"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str object</span></span><br><span class="line">s = <span class="string">"example"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str to bytes</span></span><br><span class="line">bytes(s, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes to str</span></span><br><span class="line">str(b, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># an alternative method</span></span><br><span class="line"><span class="comment"># str to bytes</span></span><br><span class="line">str.encode(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes to str</span></span><br><span class="line">bytes.decode(b)</span><br></pre></td></tr></table></figure>
<p>因为 b64encode、b64decode 只能处理二进制字符串，返回值也是二进制，所以这个函数很有用。</p>
<h4 id="完整题解">完整题解</h4>
<h2 id="￼28"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># Base64</span></span><br><span class="line"><span class="comment"># b'JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow=='</span></span><br><span class="line">cipher = <span class="string">b'JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow=='</span></span><br><span class="line">cipher_Unicode = base64.decodebytes(cipher)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode</span></span><br><span class="line"><span class="comment"># '&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119'</span></span><br><span class="line">cipher_Unicode = str(cipher_Unicode, encoding = <span class="string">'UTF-8'</span>) <span class="comment">#bytes 对象转成 string 对象</span></span><br><span class="line">cipher_Unicode = cipher_Unicode.replace(<span class="string">"&amp;#"</span>, <span class="string">""</span>)</span><br><span class="line">cipher_Unicode = cipher_Unicode.replace(<span class="string">";"</span>, <span class="string">","</span>)</span><br><span class="line">cipher_Unicode = cipher_Unicode.strip(<span class="string">","</span>) <span class="comment"># 末尾有一个';'</span></span><br><span class="line">lst = [] <span class="comment">#结果存储中介列表</span></span><br><span class="line">cipher_list = list(map(int, cipher_Unicode.split(<span class="string">','</span>))) <span class="comment">#数字存储中中介列表</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> cipher_list:</span><br><span class="line">    lst.append(chr(num))</span><br><span class="line">cipher_base_sec = <span class="string">""</span>.join(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base 64</span></span><br><span class="line"><span class="comment"># b'LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw'</span></span><br><span class="line">cipher_base_sec = bytes(cipher_base_sec, encoding = <span class="string">'UTF-8'</span>)</span><br><span class="line">cipher_ascii = base64.b64decode(cipher_base_sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100'</span></span><br><span class="line">cipher_ascii = str(cipher_ascii, encoding = <span class="string">"UTF-8"</span>)</span><br><span class="line">cipher_ascii = cipher_ascii.replace(<span class="string">'/'</span>, <span class="string">','</span>)</span><br><span class="line">cipher_ascii = cipher_ascii.strip(<span class="string">','</span>) <span class="comment"># 去掉开头的 '/'</span></span><br><span class="line">lst = [] <span class="comment">#结果存储中介列表</span></span><br><span class="line">cipher_list = list(map(int, cipher_ascii.split(<span class="string">','</span>))) <span class="comment">#数字存储中中介列表</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> cipher_list:</span><br><span class="line">    lst.append(chr(num))</span><br><span class="line">plaintext = <span class="string">""</span>.join(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试与输出</span></span><br><span class="line">f = open(<span class="string">"混合编码-cipher.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">f.write(plaintext)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></h2>
<h3 id="0x09-转轮机加密">0x09 转轮机加密</h3>
<h4 id="题目描述-v4">题目描述</h4>
<p>你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊</p>
<p>附件：转轮机加密-crypto.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:   &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;</span><br><span class="line">2:   &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;</span><br><span class="line">3:   &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;</span><br><span class="line">4:   &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;</span><br><span class="line">5:   &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;</span><br><span class="line">6:   &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;</span><br><span class="line">7:   &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;</span><br><span class="line">8:   &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;</span><br><span class="line">9:   &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;</span><br><span class="line">10:  &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;</span><br><span class="line">11： &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;</span><br><span class="line">12： &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;</span><br><span class="line">13： &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;</span><br><span class="line"></span><br><span class="line">密钥为： 2,3,7,5,13,12,9,1,8,10,4,11,6</span><br><span class="line">密文为：NFQKSEVOQOFNP</span><br></pre></td></tr></table></figure>
<h4 id="分析-v4">分析</h4>
<h5 id="转轮机加密">转轮机加密</h5>
<p>参看：<a href="https://www.iteye.com/blog/qu66q-1973053" target="_blank" rel="noopener">传统密码学(三)——转轮密码机</a><br>
是个多表替换密码。<br>
基本操作是“旋转”，其余的和本题是没有关系。</p>
<h5 id="加密表和密钥、密文的特点">加密表和密钥、密文的特点</h5>
<p>加密表每一行都有 26 个不同的字母，密钥的长度、密文长度、表格的行数都是 13，密文中字母是有重复字母的。</p>
<h5 id="猜想一：">猜想一：</h5>
<p>由此推断，密文是滚轮机的加密表某一列的字母连起来。<br>
然而经过尝试并非如此，每一行对应密文中的字母对应的序号与下一行的字母对应的序号之间的差值不能根据密钥推出！<br>
调整调整！！！是否有其他解法？</p>
<h5 id="猜想二：">猜想二：</h5>
<blockquote>
<p>跳出之前的思维，之前的思考角度是试图逆向想出它的加密方案，<br>
但是如果同时有密文和密钥，其实只要知道解密方案就好了，<br>
虽然加密和解密是逆向的过程，但是方法不同。所以可以双向思考、双向破解：</p>
<ol>
<li>根据密文密钥的特点，猜测加密方法，对密码进行攻击。</li>
<li>根据密文密钥，推测解密方法，使用解密方法对密文进行解密。</li>
</ol>
</blockquote>
<p>既然猜想一似乎没有出路了，接下来尝试 2 对应的思路。<br>
构造解密和加密的映射，加密 - 解密，密文 - 明文，密钥 - 密钥；<br>
现在的明文：<code>NFQKSEVOQOFNP</code><br>
现在的密钥：<code>2,3,7,5,13,12,9,1,8,10,4,11,6</code><br>
密钥的每个数字对应一行，那么明文的字母如果对应一列（比如以这个字母为首）,就能唯一确定一个表格。然后加密表的某一列应该会有密文（映射原来的明文）。</p>
<h4 id="题解-v4">题解</h4>
<h5 id="方法一：“手动”转">方法一：“手动”转</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转前：</span><br><span class="line">OSFEZWAXJGDLUBVIQHKYPNTCRM</span><br><span class="line">NACZDTRXMJQOYHGVSFUWIKPBEL</span><br><span class="line">FHTEQGYXPLOCKBDMAIZVRNSJUW</span><br><span class="line">FCUKTEBSXQYIZMJWAORPLNDVHG</span><br><span class="line">KCPMNZQWXYIHFRLABEUOTSGJVD</span><br><span class="line">PNYCJBFZDRUSLOQXVETAMKGHIW</span><br><span class="line">QGWTHSPYBXIZULVKMRAFDCEONJ</span><br><span class="line">QNOZUTWDCVRJLXKISEFAPMYGHB</span><br><span class="line">VUBMCQWAOIKZGJXPLTDSRFHENY</span><br><span class="line">OWTGVRSCZQKELMXYIHPUDNAJFB</span><br><span class="line">NBVCXZQWERTPOIUYALSKDJFHGM</span><br><span class="line">EIURYTASBKJDFHGLVNCMXZPQOW</span><br><span class="line">SXCDERFVBGTYHNUMKILOPJZQAW</span><br><span class="line"></span><br><span class="line">转后：</span><br><span class="line">NACZDTRXMJQOYHGVSFUWIKPBEL</span><br><span class="line">FHTEQGYXPLOCKBDMAIZVRNSJUW</span><br><span class="line">QGWTHSPYBXIZULVKMRAFDCEONJ</span><br><span class="line">KCPMNZQWXYIHFRLABEUOTSGJVD</span><br><span class="line">SXCDERFVBGTYHNUMKILOPJZQAW</span><br><span class="line">EIURYTASBKJDFHGLVNCMXZPQOW</span><br><span class="line">VUBMCQWAOIKZGJXPLTDSRFHENY</span><br><span class="line">OSFEZWAXJGDLUBVIQHKYPNTCRM</span><br><span class="line">QNOZUTWDCVRJLXKISEFAPMYGHB</span><br><span class="line">OWTGVRSCZQKELMXYIHPUDNAJFB</span><br><span class="line">FCUKTEBSXQYIZMJWAORPLNDVHG</span><br><span class="line">NBVCXZQWERTPOIUYALSKDJFHGM</span><br><span class="line">PNYCJBFZDRUSLOQXVETAMKGHIW</span><br><span class="line"></span><br><span class="line">密钥为：2,3,7,5,13,12,9,1,8,10,4,11,6</span><br><span class="line">密文为：N F Q K  S  E V O Q O  F N  P</span><br><span class="line">在第 17 行发现有语义的：FIREINTHEHOLE</span><br><span class="line">  cyberpeaceP&#123;fireinthehole&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二：写-Python-脚本（别人的-writeup）"><a href="https://www.jianshu.com/p/c43776370840" target="_blank" rel="noopener">方法二：写 Python 脚本（别人的 writeup）</a></h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">sss = <span class="string">'1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;'</span></span><br><span class="line">m = <span class="string">'NFQKSEVOQOFNP'</span></span><br><span class="line"><span class="comment"># 将sss转化为列表形式</span></span><br><span class="line">content=re.findall(<span class="string">r'&lt; (.*?) &lt;'</span>,sss,re.S)</span><br><span class="line"><span class="comment"># re.S:DOTALL，此模式下，"."的匹配不受限制，可匹配任何字符，包括换行符</span></span><br><span class="line">iv=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">6</span>]</span><br><span class="line">print(content)</span><br><span class="line">vvv=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">13</span>):</span><br><span class="line">    index=content[iv[i]<span class="number">-1</span>].index(m[i])</span><br><span class="line">    vvv.append(index)</span><br><span class="line">print(vvv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">26</span>):</span><br><span class="line">    flag=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">13</span>):</span><br><span class="line">        flag += content[iv[j]<span class="number">-1</span>][(vvv[j]+i)%<span class="number">26</span>]</span><br><span class="line">    print(flag.lower())</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x10-easychallenge">0x10 easychallenge</h3>
<h4 id="题目描述-v5">题目描述</h4>
<p>你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在 了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。</p>
<p>附件：easychallenge.pyc</p>
<h4 id="分析-v5">分析</h4>
<h5 id="pyc">.pyc</h5>
<h6 id="Python-的实质">Python 的实质</h6>
<p>其实 Python 和 Java、C# 一样，也是一门基于虚拟机的语言.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac hell.java</span><br><span class="line">java hello</span><br></pre></td></tr></table></figure>
<p>Python也是一门先编译后解释的语言。<br>
将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度<br>
并不是所有的.py文件在与运行的时候都会产生.pyc文件，只有在import相应的.py文件的时候，才会生成相应的.pyc文件</p>
<p>对于py文件，可以执行下面命令来生成pyc文件。<br>
<code>python -m foo.py</code></p>
<h6 id="Python的运行过程">Python的运行过程:</h6>
<p>在硬盘上看到的pyc文件，其实PyCodeObject才是Python编译器真正编译成的结果。<br>
当python程序运行时，编译的结果是保存在位于内存中的PyCodeObject中，<br>
当Python程序运行结束时，Python解释器则将PyCodeObject写回到pyc文件中。<br>
当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入，否则就重复上面的过程。<br>
所以，我们可以说pyc文件其实是PyCodeObject的一种持久化保存方式。</p>
<h5 id="反编译">反编译</h5>
<h6 id="方法一：使用-uncompyle6-库">方法一：使用 uncompyle6 库</h6>
<p>pip install uncompyle6<br>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/uncompyle6.png" width="500"></p>
<h6 id="方法二：在线反编译">方法二：<a href="https://tool.lu/pyc/" target="_blank" rel="noopener">在线反编译</a></h6>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/online-uncompy.png" width="500">
<h5 id="解密源代码">解密源代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode1</span><span class="params">(ans)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = ord(i) ^ <span class="number">36</span></span><br><span class="line">        x = x + <span class="number">25</span></span><br><span class="line">        s += chr(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode2</span><span class="params">(ans)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = ord(i) + <span class="number">36</span></span><br><span class="line">        x = x ^ <span class="number">36</span></span><br><span class="line">        s += chr(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode3</span><span class="params">(ans)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> base64.b32encode(ans)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="string">' '</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Please Input your flag:'</span>)</span><br><span class="line">    flag = input()</span><br><span class="line">    final = <span class="string">'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='</span></span><br><span class="line">    <span class="keyword">if</span> encode3(encode2(encode1(flag))) == final:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'correct'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'wrong'</span>)</span><br></pre></td></tr></table></figure>
<p>发现末尾有’===’，所以应该是 base32, 而非 base64<br>
encode3 -&gt; base64.b32decode(cipher)<br>
encode2, encode1 异或的解密只需要再对对应的数字异或一次就好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">()</span>:</span></span><br><span class="line">    cipher321 = <span class="string">'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='</span></span><br><span class="line">    cipher21 = base64.b32decode(cipher321)</span><br><span class="line">    cipher1 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> cipher21:</span><br><span class="line">        cipher1 += chr ( ord(char) ^ <span class="number">36</span> - <span class="number">36</span> )</span><br><span class="line">    plaintext = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> cipher1:</span><br><span class="line">        plaintext += chr ( (ord(char) <span class="number">-25</span> ) ^ <span class="number">36</span> )</span><br><span class="line">    print(plaintext)</span><br><span class="line">decode()</span><br></pre></td></tr></table></figure>
<h6 id="存在的问题-1">存在的问题 1</h6>
<p>ord()expected string of length 1,but int found<br>
参考博客，得到方法：将其变为字符串再进行ord等操作</p>
<h6 id="尝试">尝试</h6>
<p>直接转化：bytes(cipher12, encoding = ‘utf-8’)<br>
得到稀奇古怪的式子；以为解密方法不对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = chardet.detect(cipher21)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&#123;<span class="string">'encoding'</span>: <span class="string">'ISO-8859-1'</span>, <span class="string">'confidence'</span>: <span class="number">0.73</span>, <span class="string">'language'</span>: <span class="string">''</span>&#125;</span><br></pre></td></tr></table></figure>
<p>但是解密处理还是稀奇古怪的……<br>
哦哦哦！因为经过加解密，不正常才是正常的…………<br>
所以只能用最最原始的方法：直接复制为 str 类型。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">()</span>:</span></span><br><span class="line">    cipher321 = <span class="string">'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='</span></span><br><span class="line">    cipher21 = base64.b32decode(cipher321)</span><br><span class="line">    cipher21 = <span class="string">'\xa0\xbe\xa7Z\xb7\xb5Z\xa6\xa0Z\xb8\xae\xa3\xa9Z\xb7Z\xb0\xa9\xae\xa3\xa4\xad\xad\xad\xad\xad\xb2'</span></span><br><span class="line">    cipher1 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> cipher21:</span><br><span class="line">        cipher1 += chr ( (ord(char) ^ <span class="number">36</span>) - <span class="number">36</span> ) <span class="comment">#-----------</span></span><br><span class="line">    </span><br><span class="line">    plaintext = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> cipher1:</span><br><span class="line">        plaintext += chr ( (ord(char) <span class="number">-25</span> ) ^ <span class="number">36</span> )</span><br><span class="line">    print(plaintext)</span><br><span class="line">decode()</span><br></pre></td></tr></table></figure>
<h6 id="存在的问题-2">存在的问题 2</h6>
<p>Python运算符优先级<br>
<img src="/2019/09/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BA-writeup/Python运算符优先级.png" width="500"></p>
<p>惊讶地发现，位运算比四则运行优先级要低，所以<br>
<code>chr ( ord(char) ^ 36 - 36 ) -&gt; chr ( (ord(char) ^ 36) - 36 )</code></p>
<h5 id="Flag">Flag</h5>
<blockquote>
<p><code>cyberpeace{interestinghhhhh}</code></p>
</blockquote>
<hr>
<h3 id="0x11-幂数加密">0x11 幂数加密</h3>
<h4 id="题目描述-v6">题目描述</h4>
<p>你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母}</p>
<p>附件：幂数加密-crypto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8842101220480224404014224202480122</span><br></pre></td></tr></table></figure>
<h4 id="分析与题解">分析与题解</h4>
<p>幂数加密的意思用 $2^0, 2^1, 2^2, 2^3 $ 四个数字进行加密。<br>
显然……这不是云影密码吗？</p>
<blockquote>
<p>？？？？？？？？？？<br>
？？？难度 2.0 ？？？<br>
？？？？？？？？？？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">88421 122 48 2244 4 142242 248 122</span><br><span class="line">23    5   12 12   4 15     14  5</span><br><span class="line"></span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line"></span><br><span class="line">WELLDONE</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>cyberpeace{WELLDONE}</code></p>
</blockquote>
<hr>
<h3 id="0x05-easy-RSA">0x05 easy_RSA</h3>
<h4 id="题目描述-v7">题目描述</h4>
<p>解答出来了上一个题目的你现在可是春风得意，你们走向了下一个题目所处的地方 你一看这个题目傻眼了，这明明是一个数学题啊！！！可是你的数学并不好。扭头看向小鱼，小鱼哈哈一笑 ，让你在学校里面不好好听讲现在傻眼了吧~来我来！三下五除二，小鱼便把这个题目轻轻松松的搞定了。flag格式为cyberpeace{小写的你解出的答案}</p>
<p>附件：easy_RSA-crypto.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17</span><br><span class="line">求解出d</span><br></pre></td></tr></table></figure>
<h4 id="分析-v6">分析</h4>
<h5 id="gmpy2">gmpy2</h5>
<p><a href="https://gmpy2.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">https://gmpy2.readthedocs.io/en/latest/intro.html</a><br>
gmpy2是一个C编码的Python扩展模块，它支持多精度算术。gmpy2是原始gmpy模块的后继者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">invert(...):</span><br><span class="line">invert(x, m) returns y such that x * y == <span class="number">1</span> modulo m, <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">if</span> no such y exists.</span><br><span class="line">iroot(...)</span><br><span class="line"><span class="comment">#invert：n. 颠倒的事物 -&gt;乘法逆元 ： 求 x 模 m 的乘法逆元。</span></span><br><span class="line"><span class="comment">#返回值是一个 mpz 对象</span></span><br></pre></td></tr></table></figure>
<p>e * d== k * phi(n) mod n 即求 e 模 phi(n) 的乘法逆元</p>
<h4 id="题解-v5">题解</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">473398607161</span></span><br><span class="line">q = <span class="number">4511491</span></span><br><span class="line">e = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># print (gmpy2.invert(e, phin))</span></span><br><span class="line">d = (gmpy2.invert(e, phin))</span><br><span class="line"><span class="comment"># d = mpz(125631357777427553)</span></span><br><span class="line">d = <span class="number">125631357777427553</span></span><br><span class="line">cipher = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> str(d):</span><br><span class="line">    cipher += chr(ord(<span class="string">'a'</span>)+int(char) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(cipher)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cyberpeace{125631357777427553}</p>
</blockquote>
<h4 id="补充-gmpy2">补充 gmpy2</h4>
<blockquote>
<p><a href="../Notes/gmpy.md">gmpy2 笔记</a></p>
</blockquote>
<hr>
<h3 id="0x06-Normal-RSA">0x06 Normal_RSA</h3>
<h4 id="题目描述-v8">题目描述</h4>
<p>你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学 很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案 做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光</p>
<p>附件：<br>
pubkey.pem<br>
flag.enc</p>
<h4 id="分析与解">分析与解</h4>
<p>目前只有保存公钥和密文的文件，故意味着公钥一定是可以攻击的。</p>
<h5 id="从文件中提取信息">从文件中提取信息</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL&gt;rsa -in pubkey.pem -text -publin</span><br></pre></td></tr></table></figure>
<image src="text-qu.png" width="500/">
<p>更好的方式是把模数（大整数 n ）提取出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl&gt;rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br></pre></td></tr></table></figure>
<image src="text-qu-m.png" width="500/">
<p>从而获得模数：<br>
<code>Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD</code></p>
<h5 id="信息基本处理">信息基本处理</h5>
<p>显然是十六进制，需要转化成十进制。</p>
<blockquote>
<p>偷懒用网站工具：<a href="https://www.sojson.com/hexconvert/16to10.html" target="_blank" rel="noopener">https://www.sojson.com/hexconvert/16to10.html</a><br>
然后就是报应……<br>
得到十进制：<br>
<code>87924348264132512606026244266860026602226062424884468222066668822204828484286</code><br>
因式分解之后会发现居然不是两个素数的乘积……<br>
显然是因为数字发生错误了，所以是在转换的时候，网站在处理大整数的时候发生偏差。</p>
</blockquote>
<p><strong>进制转化：</strong></p>
<blockquote>
<p>1.其他进制转十进制<br>
函数：int(number_str, base_number)<br>
第一个参数是内容是数值类型的字符串，第二个参数是字符串内容数值的基数。<br>
返回十进制数值型变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0xf'</span>,<span class="number">16</span>)</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'10100111110'</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">1342</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'17'</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>2.转十六进制<br>
hex(decimal_numeral) 函数<br>
参数是十进制数值<br>
如果是其他进制的字符串，需要先用 int() 函数转化成 十进制数值，再用 hex()<br>
返回对应类型的字符串（十六进制）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">1033</span>)</span><br><span class="line"><span class="string">'0x409'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(int(<span class="string">'101010'</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(int(<span class="string">'17'</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>3.转二进制<br>
bin(decimal_numeral) 函数<br>
参数是十进制数值，和十六进制类似。<br>
如果是其他进制的字符串，需要先用 int() 函数转化成 十进制数值，再用 bin()<br>
返回对应类型的字符串（二进制）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">10</span>)</span><br><span class="line"><span class="string">'0b1010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(int(<span class="string">'ff'</span>,<span class="number">16</span>))</span><br><span class="line"><span class="string">'0b11111111'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(int(<span class="string">'17'</span>,<span class="number">8</span>))</span><br><span class="line"><span class="string">'0b1111'</span></span><br></pre></td></tr></table></figure>
<p>4.转八进制<br>
oct(decimal_numeral) 函数<br>
其余的类型。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(<span class="string">'C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD'</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>大整数因数分解：<br>
<image src="./fac.png" width="800/"></image></p>
<h5 id="生成私钥文件">生成私钥文件</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">275127860351348928173285174381581152299</span></span><br><span class="line">q = <span class="number">319576316814478949870590164193048041239</span></span><br><span class="line">e = <span class="number">65537</span></span><br></pre></td></tr></table></figure>
<p><code>rsatool.py</code> 放进当前目录下，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python rsatool.py -out private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239</span><br></pre></td></tr></table></figure>
<p>发现 Python2.7 虽然能够运行命令，但是会报错。猜测这个是用 Python3 写的，一些处理上不兼容，所以换了 Python3 ：<br>
<image src="Python3-private.png" width="800"></image></p>
<p>此刻目录下生成了，private.pem</p>
<h5 id="用私钥解密">用私钥解密</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wcb534@Ubuntu:~/<span class="variable">$openssl</span></span><br><span class="line">OpenSSL&gt;rsautl -decrypt -<span class="keyword">in</span> flag.enc -inkey private.pem -out message.txt</span><br><span class="line">OpenSSL&gt;<span class="built_in">exit</span></span><br><span class="line">wcb534@Ubuntu:~/$ vim message.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PCTF{256b_i5_m3dium}</p>
</blockquote>
<h5 id="OpenSSl">OpenSSl</h5>
<p>详见：<a href="https://zer0-nu1l.github.io/2019/09/29/OpenSSL/#more%C2%B7">OpenSSL</a></p>
<h5 id="rsatool">rsatool</h5>
<p>官方的 <a href="http://README.md" target="_blank" rel="noopener">README.md</a> 写的很简洁，也只给了两个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python rsatool.py -f PEM -o key.pem -n 13826123222358393307 -d 9793706120266356337</span><br><span class="line">python rsatool.py -f DER -o key.der -p 4184799299 -q 3303891593</span><br></pre></td></tr></table></figure>
<p>基本格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python rsatool.py [-p P] [-q Q] [-n N] [-e E] [-d D] [-h] [-o] [-f] [-v]</span><br><span class="line"><span class="comment"># -p -q -e -</span></span><br><span class="line"><span class="comment"># -f format PEM/DER；</span></span><br><span class="line"><span class="comment"># -o out；</span></span><br><span class="line"><span class="comment"># -o 和 -f 有对应关系</span></span><br><span class="line"><span class="comment"># -f PEM -o key.pem | -f DER -o key.der</span></span><br></pre></td></tr></table></figure>
<p>目前只用来生成 pem 文件……<br>
rsatool 还有更多的功能。（还有RSA-CRT）<br>
更多见：<a href="https://github.com/adeptex/rsatool" target="_blank" rel="noopener">https://github.com/adeptex/rsatool</a></p>
<hr>
<h3 id="0x12-easy-ECC">0x12 easy_ECC</h3>
<h4 id="题目分析">题目分析</h4>
<p>这个题目只是实现 ECC 的加密，没有太大的难度。</p>
<p>CTF - Wiki 上的 2013 年 SECCON CTF quals 中的 <a href="https://github.com/sonickun/ctf-crypto-writeups/blob/master/2013/seccon-ctf-quals/cryptanalysis/20140127213558.png" target="_blank" rel="noopener">Cryptanalysis</a> 需要对 ECC 进行爆破，比较有趣。</p>
<p>先实现椭圆曲线上的加法运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line">p = <span class="number">15424654874903</span></span><br><span class="line">a = <span class="number">16546484</span></span><br><span class="line">b = <span class="number">4548674875</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> A == (<span class="number">0</span>, <span class="number">0</span>): <span class="keyword">return</span> B</span><br><span class="line">    <span class="keyword">if</span> B == (<span class="number">0</span>, <span class="number">0</span>): <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    x1, y1 = A</span><br><span class="line">    x2, y2 = B</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> A != B:</span><br><span class="line">        λ = (y2 - y1) * pow((x2 - x1), p<span class="number">-2</span>, p)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        λ = (x1*x1*<span class="number">3</span> + a) * pow(<span class="number">2</span>*y1, p<span class="number">-2</span>, p)</span><br><span class="line">    </span><br><span class="line">    x3 = λ * λ - x1 - x2</span><br><span class="line">    y3 = λ * (x1 - x3) - y1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (x3 % p, y3 % p)</span><br></pre></td></tr></table></figure>
<p>由于 M 是素数，所以由费马小定理可知 $(x_2 - x_1)^{M-1} = 1 \pmod {M}$，</p>
<p>所以 $x_2 - x_1$ 的乘法逆元是 $(x_2 - x_1)^{M-2}$，同理，$y_2 - y_1$ 的乘法逆元是 $(y_2 - y_1)^{M-2}$.</p>
<p>接下来进行乘法运算（加密）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = (<span class="number">6478678675</span>,<span class="number">5636379357093</span>)</span><br><span class="line">k = <span class="number">546768</span></span><br><span class="line">C = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">    C = add(C, G)</span><br><span class="line">print(C)</span><br><span class="line">print(<span class="string">"cyberpeace&#123;%d&#125;"</span>%(C[<span class="number">0</span>]+C[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># cyberpeace&#123;19477226185390&#125;</span></span><br></pre></td></tr></table></figure></image></image>]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>攻防世界</tag>
      </tags>
  </entry>
</search>
