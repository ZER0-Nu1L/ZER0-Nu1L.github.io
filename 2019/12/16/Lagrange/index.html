<!DOCTYPE html><html class="theme-next pisces use-motion" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="QvPZ3tgcDy_FQ1Ivu9CLCAEPdzhAyW8GzyQ1APQgiVg"><meta name="baidu-site-verification" content="ueLXt8dSC9"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-crypto.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-crypto.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="QoS,Lagrange Relaxation,矩阵,次梯度,"><link rel="alternate" href="/atom.xml" title="ZER0-Nu1L" type="application/atom+xml"><meta name="description" content="概要 在做网络应用的时候，往往会涉及到 QoS （Quality of Service）算法。 同时在应用平面，服务质量保证是非常重要的一环。   图0  学习的障碍主要在于：  没有系统地学习过运筹学（凸优化）等知识 论文中往往默认读者有相应的知识储备，对于一些可能比较关键的部分直接跳过。（都靠自己猜想和反推得到） 论文中有不少纰漏与缺憾。  这篇文章致力于以深入浅出的方式介绍 QoS 算法中的"><meta property="og:type" content="article"><meta property="og:title" content="【深入浅出】基于拉格朗日松弛法的多约束 QoS 路由算法"><meta property="og:url" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/index.html"><meta property="og:site_name" content="ZER0-Nu1L"><meta property="og:description" content="概要 在做网络应用的时候，往往会涉及到 QoS （Quality of Service）算法。 同时在应用平面，服务质量保证是非常重要的一环。   图0  学习的障碍主要在于：  没有系统地学习过运筹学（凸优化）等知识 论文中往往默认读者有相应的知识储备，对于一些可能比较关键的部分直接跳过。（都靠自己猜想和反推得到） 论文中有不少纰漏与缺憾。  这篇文章致力于以深入浅出的方式介绍 QoS 算法中的"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/%E5%8C%80%E9%80%9F%E7%B4%AF%E7%A7%AF.png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/%E6%AC%A1%E5%AF%BC%E6%95%B0.png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/Z(lambda).png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/%E6%A2%AF%E5%BA%A6.png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/sup.png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/c.png"><meta property="og:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/graph.png"><meta property="article:published_time" content="2019-12-15T16:55:12.000Z"><meta property="article:modified_time" content="2020-03-31T12:44:04.465Z"><meta property="article:author" content="Andy Wu"><meta property="article:tag" content="QoS"><meta property="article:tag" content="Lagrange Relaxation"><meta property="article:tag" content="矩阵"><meta property="article:tag" content="次梯度"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zer0-nu1l.github.io/2019/12/16/Lagrange/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://zer0-nu1l.github.io/2019/12/16/Lagrange/"><title>【深入浅出】基于拉格朗日松弛法的多约束 QoS 路由算法 | ZER0-Nu1L</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ZER0-Nu1L</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">In me the tiger sniffs the rose.</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> Archives</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> About</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://zer0-nu1l.github.io/2019/12/16/Lagrange/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Andy Wu"><meta itemprop="description" content=""><meta itemprop="image" content="/uploads/Profile.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZER0-Nu1L"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">【深入浅出】基于拉格朗日松弛法的多约束 QoS 路由算法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-16T00:55:12+08:00">2019-12-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/SDN/" itemprop="url" rel="index"><span itemprop="name">SDN</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/SDN/QoS/" itemprop="url" rel="index"><span itemprop="name">QoS</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">Words count in article&#58;</span> <span title="Words count in article">7.9k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">31</span></div></div></header><div class="post-body" itemprop="articleBody"><h1>概要</h1><p>在做网络应用的时候，往往会涉及到 QoS （Quality of Service）算法。<br> 同时在应用平面，服务质量保证是非常重要的一环。<br> <img src="/2019/12/16/Lagrange/系统架构图.png" width="700"></p><p align="center"> 图0</p><p>学习的障碍主要在于：</p><ol><li>没有系统地学习过运筹学（凸优化）等知识</li><li>论文中往往默认读者有相应的知识储备，对于一些可能比较关键的部分直接跳过。（都靠自己猜想和反推得到）</li><li>论文中有不少纰漏与缺憾。</li></ol><p>这篇文章致力于以深入浅出的方式介绍 QoS 算法中的 基于拉格朗日松弛法的多约束 QoS 路由算法。<br> 虽然对于论文中的一些部分没有吃透，但最重要的是通过整个过程，将 QoS 算法中默认读者储备的运筹学的知识展现出来。其中主要包括线性变换关系和次梯度。线性变换关系主要是为了将我们面对的网络路由算法抽象成数学问题，次梯度算法是为了找到最优解。</p><a id="more"></a><h1>线性变换关系</h1><blockquote><p>这一部分对于后面将拉格朗日松弛法引入路由算法，以及从单约束路由算法扩展到多约束路由算法至关重要。<br> 注：原本打算使用其他的例子，但是始终找不出比于建国博士举的更通俗例子，所以沿用之。</p></blockquote><h2 id="单因素积累单因素-标量×标量">单因素积累单因素 - 标量×标量</h2><p>加法是一种简单的计数模型。</p><blockquote><p>现在考虑下面这种情况：有 3 只斑马，现在要计数每个斑马的眼睛。<br> 经过九年义务教育的我们一定会不假思索用 $3 \times 2$ 来进行计算。这蕴含的是乘法的意义。</p></blockquote><p>乘法是加法的“指数运算”，由加法迭代而成。<br> 虽然上面的例子我们可以用原来的加法计数模型 6 次得到答案，但是我们很快发现每个斑马有 2 只眼睛，<strong>比例</strong>不变，于是乘法非常方便地计数这种<strong>单此累积量始终不变</strong>的加法 。<br> $$<br> y = w \times x<br> $$<br> 在乘法式子中， y 表示因变量，是一种积累量，x 表示自变量，是一个积累因素，而 w 表示累计的速度。<br> 对应之前的例子是：<br> $$<br> y(\text{眼睛总数量})<br> = a(\text{每个斑马的眼睛数量}) \times x(\text{斑马个数})<br> $$</p><h2 id="多因素累积单因素-向量×向量">多因素累积单因素 - 向量×向量</h2><blockquote><p>想知道斑马和小鸟共有多少只眼睛</p></blockquote><p>现在出现了 2 个积累因素。</p><p>$$\begin{array}{cc}<br> y = w_1 \times x_1 + w_2 \times x_2 \\<br> x_1:\text{班马个数}, ; x_2:\text{小鸟个数}, ; y:\text{脚总数} \\<br> w_1:\text{斑马眼睛数量}, 4, ; w_2:\text{小鸟眼睛数量},2<br> \end{array}$$</p><blockquote><p>想知道斑马、小鸟、老鼠、狮子……共有多少只眼睛</p></blockquote><p>此时出现了多个积累因素，原来的乘法显得笨拙，也就出现了<strong>向量（vector）</strong>。<br> 将不同因素按照固定顺序排列，用一个量来表示这些因素的整体。向量的维度对应因素的个数。<br> $$<br> x = (x_1, x_2, … x_n)<br> $$</p><p>回到刚刚的例子，<br> 可用一个向量 $x=[x_1, x_2]$ 来代表斑马和小鸟分别有多少只；<br> 再用一个向量 $w=[w_1, w_2]$ 来表示每个斑马和小鸟分有多少只腿。<br> 注：之所以用字母 w ，是代表 weight 权重。</p><h2 id="多因素累积多因素-矩阵×向量">多因素累积多因素 - 矩阵×向量</h2><blockquote><p>不仅想要知道一共有多少个眼睛，还想知道有多少条腿时</p></blockquote><p>可以用两个有序排列的向量来代表两组权重，也就形成了矩阵。<br> $$<br> x=<br> \begin{bmatrix}<br> x_1 \\<br> x_2<br> \end{bmatrix} \tag{1}<br> $$</p><p>$$<br> W=<br> \begin{bmatrix}<br> w_1 \\<br> w_2<br> \end{bmatrix} =<br> \begin{bmatrix}<br> w_{11} &amp; w_{12} \\<br> w_{21} &amp; w_{22}<br> \end{bmatrix} \tag{2}<br> $$</p><p>$$<br> y=<br> \begin{bmatrix}<br> y_1 \\<br> y_2<br> \end{bmatrix} \tag{3}<br> $$</p><p>$$<br> b=<br> \begin{bmatrix}<br> b_1 \\<br> b_2<br> \end{bmatrix} \tag{4}<br> $$</p><p>$$<br> y = WX+b<br> $$</p><p>$$\begin{array}{cc}<br> x_1:\text{班马个数}, ; x_2:\text{小鸟个数} \\<br> w_{11}:\text{斑马眼睛数量} ; w_{12}:\text{小鸟眼睛数量}, ; y_1:\text{腿总数} \\<br> w_{21}:\text{斑马腿数量}, ; w_{22}:\text{小鸟腿数量}, ; y_2:\text{眼总数} \\<br> b_1:\text{积累前腿数量}, ; b_2:\text{积累前腿数量}<br> \end{array}$$</p><p>由于 W 和 b 这两个变量的作用是用于描述输入 x 和输出 y 之间的关系。也把它们统称为参数（parameters）。</p><h2 id="批量多因素积累多因素-矩阵×矩阵">批量多因素积累多因素 - 矩阵×矩阵</h2><blockquote><p>如果第一次看见了 3 个斑马和 1 只鸟，第二次看到了 4 个斑马和 1 只鸟。想要知道两次分别有多少条腿，还想知道有多少个眼睛。</p></blockquote><p>就可以可以把所有（观察到的）x 并成矩阵来一次性批量计算。<br> 在图像识别里，用会把一张图片切成一个行向量，然后由多个行向量组成一个矩阵。<br> 通过矩阵运算就能实现图像的批量处理。</p><h3 id="例子">例子</h3><blockquote><p>应用实例: 职工轮训</p><p>实例某公司为了实现技术更新，计划对职工实行分批脱产轮训。<br> 现有职工中不脱产职工8000人，脱产轮训职工2000人。<br> 若每年从不脱产职工中抽调30%的人脱产轮训，同时又有60%脱产轮训职工结业回到生产岗位。<br> 若职工总数保持不变，一年后不脱产职工及脱产轮训职工各有多少？两年后又怎样？</p></blockquote><p>分析：<br> 两个积累因素：不脱产职工人数和脱产轮训职工人数；<br> 两个积累的权重：脱产轮训率和回归生产率；<br> $$<br> \left(<br> \begin{array}{ll}<br> {0.70} &amp; {0.60} \\<br> {0.30} &amp; {0.40}<br> \end{array}<br> \right)<br> \left(<br> \begin{array}{l}<br> {8000} \\<br> {2000}<br> \end{array}<br> \right)=<br> \left(<br> \begin{array}{l}<br> \text{不脱产的职工数} \\<br> \text{脱产的职工数}<br> \end{array}<br> \right)<br> $$</p><h2 id="线性变化关系总结">线性变化关系总结</h2> <img src="/2019/12/16/Lagrange/匀速累积.png" width="500"><p align="center"> 图1：匀速累积模型</p> ---<h1>次梯度法</h1><h2 id="次梯度的概念">次梯度的概念</h2><p>参考：<a href="https://blog.csdn.net/qq_32742009/article/details/81704139" target="_blank" rel="noopener">【机器学习】次梯度（subgradient）方法</a></p><blockquote><p>次导数（subderivative）、次微分（subdifferential）、次切线（subtangent lines）和次梯度（subgradient）的概念出现在凸分析，也就是凸函数的研究中。</p></blockquote><p>梯度（导数）的概念大家都知道，次梯度可以说是对梯度的一种补充（次导数是对导数的一种补充）。因为有些函数是不可导的，比如前面的图 2 就是一个不可导的函数。</p><p>不妨从一元函数的图像理解，和导数一样，先做函数一个点的切线（和函数只有一个交点的直线）。但是不连续的函数可能有多个，这也意味着次导数有多个，或者说是处于一个区间。<br> <img src="/2019/12/16/Lagrange/次导数.png" width="300"></p><p align="center"> 图2：次导数</p><p>图中蓝线表示函数，红线的斜率都在次导数的区间内。<br> <strong>点 $x_0$ 的次导数</strong>的集合是一个非空闭区间[a, b]，其中 a 和 b 是单侧极限:<br> $$<br> \begin{aligned}<br> a=\lim_{x→x_{^-0}} \frac{f(x)−f(x_0)}{x−x_0} \\<br> b=\lim_{x→x{^+0}} \frac{f(x)−f(x_0)}{x−x_0}<br> \end{aligned}<br> $$</p><p>所有次导数的集合 $[a,b]$ 称为函数 $f$ 在 $x_0$ 的<strong>次微分</strong>。</p><p>例如：考虑凸函数 $f(x)=|x|$。在原点的次微分是区间 $[−1, 1]$ 。<br> $x_0&lt;0$时，次微分是单元素集合{-1}，而 $x_0&gt;0$，则是单元素集合{1}。</p><p>同样的道理推广到多元函数就有<strong>次梯度</strong>的概念。<br> $$<br> f(x) \geq f\left(x_{0}\right)+g^{T}\left(x-x_{0}\right)<br> $$</p><p>导数或者梯度等于零的时候说明取到极值，对应地，如果次导数或者次梯度的区间范围内包含零，也就说明在改点取到极值。<br> $$<br> f \left(x^{* }\right)=\min_{x} f(x) \Leftrightarrow 0 \in \partial f\left(x^{*}\right)<br> $$</p><h2 id="基本次梯度算法">基本次梯度算法</h2><blockquote><p>参考维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E6%A2%AF%E5%BA%A6%E6%B3%95" target="_blank" rel="noopener">次梯度法</a></p></blockquote><h3 id="迭代方法">迭代方法</h3><p>记 $f:\mathbb{R}^n \to \mathbb{R}$ 为定义在 $\mathbb{R}^n$ 上的凸函数。<br> 次梯度算法使用以下的迭代格式:<br> $$<br> x^{(k+1)} = x^{(k)} - \alpha_k g^{(k)}<br> $$</p><p>其中 $g^{(k)}$ 表示函数 $f$ 在 $x^{(k)}$ 的次梯度. 如果 $f$ 可微，他的次梯度就是梯度向量$\nabla f$.<br> 有时，$-g^{(k)}$ 不是函数 $f$ 在 $x^{(k)}$ 处的下降方向。因此采用一系列可能的 $f_{\rm{best}}$ 来追踪目标函数的极小值点，即:<br> $$<br> f_{\rm{best}}^{(k)} = \min {f_{\rm{best}}^{(k-1)} , f(x^{(k)}) }<br> $$</p><h3 id="步长的选取">步长的选取</h3><p>与梯度下降算法不同的是：次梯度算法没有明确的步长选择方法，有许多可采用的步长。以下为5种能够保证收敛性的步长规则:</p><ul><li>恒定步长，$\alpha_k = \alpha$。</li><li>恒定间隔，$\alpha_k = \gamma/\lVert g^{(k)} \rVert_2$，得出$\lVert x^{(k+1)} - x^{(k)} \rVert_2 = \gamma$。</li><li>步长平方可加，但步长不可加，即步长满足:<br> $\alpha_k\geq0,\qquad\sum_{k=1}^\infty \alpha_k^2 &lt; \infty,\qquad \sum_{k=1}^\infty \alpha_k = \infty$。</li><li>步长不可加但步长递减，即步长满足:<br> $\alpha_k\geq0,\qquad \lim_{k\to\infty} \alpha_k = 0,\qquad \sum_{k=1}^\infty \alpha_k = \infty$。</li><li>间隔不可加但间隔递减，即$\alpha_k = \gamma_k/\lVert g^{(k)} \rVert_2$，其中:<br> $\gamma_k\geq0,\qquad \lim_{k\to\infty} \gamma_k = 0,\qquad \sum_{k=1}^\infty \gamma_k = \infty$。<br> 注意：上述步长是在算法执行前所确定的，不依赖于算法运行过程中产生的任何数据。这是与标准梯度下降法的显著区别。</li></ul><h3 id="停止条件">停止条件</h3><p>这一部分维基百科没有说明。我也是打算放进我们后续的算法中说明，因为后续的算法的场景更小，停止条件更有针对性。对这方面有兴趣的也可以自行学习。</p><hr><h1>拉格朗日松弛法（Lagrange Relaxation）</h1><h2 id="要解决的问题">要解决的问题</h2><p>拉格朗日松弛应用于求解约束规划问题。<br> 数学描述为：<br> $$<br> \begin{aligned}<br> z_{1}= \min c^{T} x \\<br> s.t. Ax \geq b \\<br> x\in Z_{+}^{n}<br> \end{aligned}<br> $$<br> 其中 $z_{1}=\min c^{T} x$ 是没有约束条件时的最小值，但现在有了 $Ax \geq b$ 这样的约束条件，原来的最优解不一定会满足约束条件。</p><h3 id="扩展">扩展</h3><p>我们可以对 x 的取值进行合理扩展。原式子中有 $x\in Z_{+}^{n}$，我可以把它扩展成多个因素，也就是向量 $x=[x_1, x_2, …, x_n]^T$。（从运筹学教材中广泛使用向量、矩阵得到的灵感）<br> 而 $c=[c_1, c_2, …, c_n]$，c 可以理解成 const 或者 cost（代价）。</p><h2 id="基本原理">基本原理</h2><h3 id="基本思想">基本思想</h3><p>拉格朗日松弛是求解下界的一种方法。核心的思想是将造成问题难的约束吸收到目标函数中，使问题容易求解。<br> 将 $Ax \geq b$ 变成 $0 \geq b - Ax$ 乘上拉格朗日乘子（非负）$\lambda ^T$，加入到 $z_{1}=\min c^{T} x$ 中，即构成拉格朗日松弛式：<br> $$<br> z_{LR}(\lambda)=\min c^{T} x+\left(\lambda^{T}\right)(b-A x)<br> $$<br> 由于 $b - Ax \leq 0$，所以 $ z_{LR}(\lambda) \leq z_{IP} $。其中 $z_{IP}$ 表示 LR 的一个可行解。<br> 此时，原理的问题求解变成了选择最优的拉格朗日乘子。</p><h3 id="选择最优的拉格朗日乘子">选择最优的拉格朗日乘子</h3> <img src="/2019/12/16/Lagrange/Z(lambda).png" width="500"> 图2：拉格朗日松弛式函数图像<p>$z_{LR}(\lambda)$ 是一个<strong>凹函数</strong>（向上凸）。（对应的，向下凸为凸函数）<br> 如果它是光滑的（可微），就用<strong>梯度法</strong>来寻找最优的拉格朗日乘子；<br> 如果它是非光滑的（不可微），就用<strong>次梯度法</strong>来寻找最优的拉格朗日乘子；</p><h4 id="梯度法">梯度法</h4><p>梯度法简单介绍，因为这篇文章后续应用的是次梯度法。<br> <img src="/2019/12/16/Lagrange/梯度.png" width="400"></p><p align="center"> 图3：一元函数梯度下降</p><p>基本步骤：任给一个初始出发点，设为X0，</p><ol><li>设定一个步长d；</li><li>计算该点当前梯度（导数）$y’$；</li><li>修改当前参数$x_1=x_0+d*y’$</li><li>计算该点当前梯度（导数）$y’$；<br> …重复…</li></ol><blockquote><p>当然有很多优化的梯度下降法，这里从略。</p></blockquote><h4 id="次梯度法">次梯度法</h4><p>之前已经介绍过次梯度的概念。<br> 需要解决的问题是步长的选择和停止条件。</p><h5 id="步长的选择">步长的选择</h5><p>虽然前面列举了若干种方法，但在 Stanford University 的课程中提到了一种很适合的步长选取方法（Polyak’ rule）：<br> $$<br> \begin{array}{l}<br> {\text { Optimal step size when } f^{\star} \text { is known }} \\<br> {\text { choice due to Polyak: }} \\<br> {\qquad \alpha_{k}=\frac{f\left(x<sup>{(k)}\right)-f</sup>{\star}}{\left|g<sup>{(k)}\right|_{2}</sup>{2}}} \\<br> {\text { (can also use when optimal value is estimated) }}<br> \end{array}<br> $$</p><p>$$<br> \begin{array}{l}<br> {\text { motivation: start with basic inequality }} \\<br> {\qquad \left | x^{(k+1)} - x^{\star} \right | _{2} ^{2} \leq \left | x^{(k)} - x^{\star} \right | _{2}^{2} - 2\alpha_{k} \left (f \left(x^{(k)} \right) - f^{ \star }\right) + \alpha_{k}<sup>{2}\left|g</sup>{(k)}\right|_{2}^{2}} \\<br> {\text { and choose } \alpha_{k} \text { to minimize righthand side }}<br> \end{array}<br> $$</p><p>…<br> …<br> （后续还有很多，没有搬过来，有兴趣可以自己查阅）<br> 若是最优值 $f(x^*)$ 可知则可以用这种方法。<br> 其中 ${\left | g^{(k)} \right |_{2}}$ 称为欧几里得范数，表示从原点出发到向量 $x$ 确定的点的欧几里得距离。也就是：<br> $$<br> |x|_{2} = \left(\sum_{i}\left|x_{i}\right|<sup>{2}\right)</sup>{\frac{1}{2}}<br> $$</p><p>欧几里得范数在机器学习中出现地十分频繁，经常省略下标2，简写成${\left|x\right|}$，所以这里的步长很多地方也在写作:<br> $$\alpha_{k}=\frac{f\left(x<sup>{k}\right)-f\left(x</sup>{*}\right)}{\left|g<sup>{k}\right|</sup>{2}}$$</p><h5 id="停止条件-v2">停止条件</h5><ol><li>迭代次数不超过$T$。这是一种最为简单的原则，但解的质量无法保证。</li><li>$s^t=0$ 。这是最为理想的状态，此时，达到拉格朗日对偶的最优解。<br> 在实际计算中，由于问题的复杂性和计算机本身的计算误差，这样的结果难达到，常常用$||s^t|| \le \epsilon$（c为给定的非负数）来代替。</li><li>$z_{UP}(t)=z_{LB}(t)$。在 $z_{UP}(t)$ 和 $z_{LB}(t)$ 可变时，这种情况表示已得到原问题的最优解。最优解为 $z_{IP}=z_{UP}(t)=z_{LR}(t)$.</li><li>$\lambda^t$或者目标值 $z_{LR}(\lambda^t)$ 在规定的步数内变化不超过一个给定的值。</li></ol><h4 id="应用次梯度法于拉格朗日松弛">应用次梯度法于拉格朗日松弛</h4><p>构造的拉格朗日松弛式为：<br> $$<br> z_{LR}(\lambda)=\min c^{T} x+\left(\lambda^{T}\right)(b-A x)<br> $$<br> 由于次梯度是不唯一的，所以选择其中一个即可。</p><h5 id="算法步骤：">算法步骤：</h5><ol><li>任选一个初始拉格朗日乘子 $\lambda^1, t=1.$</li><li>对 $\lambda ^t$，任选一个次梯度 $s^{i}$；若 $s^{i}=0$，则 $\lambda ^t$ 达到最优解而停止计算。否则 $\lambda ^t = max[ \lambda ^t + \theta_t s^t, 0 ]$, t = t+1，重复迭代。</li></ol><p>这里选取 $s^{i}=b-A x^{i}$ 作为梯度。<br> $i$ 表示第 $i$ 次迭代，$x^i$ 表示 $z_{LR}(\lambda)$ 的一个可行解。<br> 步长 $\theta_t$ 依照前面的 Polyak 准则：<br> $$<br> \theta_{t}=\frac{z_{UP}(t)-z_{LR}(t)}{\left|s<sup>{t}\right|</sup>{2}} \beta_{t}<br> $$<br> $z_{UP}(t)$ 为原问题的一个上界，可以由一个可行解的目标值确定，也可以通过估计的方法得到。<br> 可随 t 的变化逐步修正。<br> $z_{LR}(t)$为问题的下界，取 $z_{UP}(t)=z_{LR}(t)$.<br> $0 \le \beta_t \le 2$，一般取 $\beta_0 =2$。<br> 当 $z_{LR}(t)$ 上升的时候，$\beta_t保持不变$；<br> 当 $z_{LR}(t)$ 在给定的若干步没有变化时，取其 $\frac{1}{2}$.</p><h4 id="简单应用">简单应用</h4><p>在网络上流传的一份拉格朗日松弛算法的课件里面有一道简单应用，可以作为巩固理解的练习题，由于没有加入任何笔者的个人理解，这里不做搬运工了。<br> 参看百度文库里的一个课件：<a href="https://wenku.baidu.com/view/550fe416abea998fcc22bcd126fff705cd175c56.html" target="_blank" rel="noopener">拉格朗日松弛</a></p><h2 id="用途">用途</h2><ol><li>对于线性整数规划问题，将难约束吸收到目标函数后，问题变得容易求解。虽然不一定是可行解，但是可以求得下界。</li><li>实际的计算结果证实拉格朗日松弛方法所给的下界相当不错，且计算时间可以接受。可以用于拉格朗日松弛的启发式算法（也就是我们马上就会用到的）。认为目标值不可能再变化，因此，停止运算。</li></ol><h1>QoS</h1><blockquote><p>终于到了 QoS 算法，不过不用担心，如果前面的部分已经理解，后面的除了论文有很多坑以外，已经没有太多比较难理解的了（可能吧）。</p></blockquote><h2 id="QoS-和-拉格朗日松弛法的关系">QoS 和 拉格朗日松弛法的关系</h2><h3 id="QoS-问题简介">QoS 问题简介</h3><blockquote><p>服务质量(QoS)是计算机网络研究领域的一个热点问题，目的是为用户在网络中搜索满足业务需求的路径。<br> QoS 路由的度量参数包括带宽、代价、延迟、延迟抖动、丢失率和跳数等。根据运算规则, 这些度量参数可分为加性度量参数、乘性度量参数和凹性度量参数。QoS 度量参数中, 代价、延迟等属于加性度量参数, 丢失率属于乘性参数, 带宽属于凹性参数。搜索 QoS 路径过程中, 可以删除不满足凹性参数的链路, 而乘性参数可通过取对数变为加性参数, 所以 QoS 路由算法主要是搜索到满足一个或多个加性度量参数的路径。<br> 已经能证明多个加性度量的QoS 路由问题属于 NP 完全问题。<br> —— 《基于拉格朗日松驰的多约束QoS路由算法》</p></blockquote><h3 id="传统算法和拉格朗日松弛法">传统算法和拉格朗日松弛法</h3><blockquote><p>Dijkstra 算法是最短路径算法中的比较经典的算法，但只适用于求解单维权重图，对于多维权重图<br> 的多约束路径问题，Dijkstra 算法难以胜任。拉格朗日松弛法是求解组合优化问题的常用方法，其基本思想是将约束条件吸收到目标函数中，使目标函数仍保持线性，并使得问题容易求解，从而可以在多项式时间内求出最优解或可行解。<br> ——《一种基于拉格朗日松弛法的QoS路由算法》</p></blockquote><h2 id="论文介绍">论文介绍</h2><p>最开始拿到的论文是 <code>[1]何涛,王锁萍,张明.一种基于拉格朗日松弛法的QoS路由算法[J].电路与系统学报,2010,15(01):37-40.</code>，起初觉得这篇论文提出拉格朗日松弛的文字还是蛮流畅的，但是到 <code>4.1 算法相关的结论与证明</code> 部分，就觉得有点奇怪了，虽然它的证明没有太大问题，但是形式上已经和我所理解的拉格朗日松弛开始脱节。</p><h3 id="论文缺憾">论文缺憾</h3><ol><li>它的拉格朗提松弛式构造成了：$d§-\Delta_{\text {delay}}+\lambda c§ $，也就是把要求解的最小代价吸附到约束条件上，这个思路和正常的拉格朗日松弛式相反的；虽然如果运算的时候把他构造的式子两边同除以 $\lambda$，把 $\lambda$ 当成原来的 $\frac{1}{\lambda}$，会回到正常的拉格朗日松弛式，但是又何必如此大费周章？后来找了很多其他论文，也证明了他们的思路和我都是一致的。</li><li>这篇论文的第二个遗憾是除了文字表面提了拉格朗日松弛，在算法实现步骤中并看不出来是拉格朗日松弛，确认极值的时候也是用自己证明的一些定理。最让我感到困惑的是在算法分析部分“故每次迭代后的路径总是优于上次迭代的结果”的理由不能让我信服。</li><li>最后一个的缺憾，私以为是算法步骤中的数学符号没有加以说明，难以理解。在文章前面部分数学符号的解释的位置放得恰到好处，而这一部分并没有处理得那么优秀。</li></ol><h3 id="IEEE-论文">IEEE 论文</h3><p>之后找到了另一篇论文 <code>[1]Juttner, A., Szviatovski, B., Mecs, I., Rajko, Z.. Lagrange relaxation based method for the QoS routing problem[P]. INFOCOM 2001. Twentieth Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings. IEEE,2001.</code>，<br> 两个事情让我很震惊。<br> 第一个是之前看到的论文和这一篇近似度极高…… 而这篇论文发表比前一篇早大概 9 年。并且我不觉得前一篇论文相对这一篇论文有什么创新，还缺乏了不少内容，甚至很有必要的说明部分略去了。<br> 另外一件事是这篇 IEEE 论文也有一些谬误。</p><ol><li><p>在 <code>III. PROPOSED ALGORITHM C. Running time of the algorithm</code> 部分，符号的下标写错了：<br> <img src="/2019/12/16/Lagrange/sup.png" width="500"></p></li><li><p>在<code>III. PROPOSED ALGORITHM B. The description of the algorithm</code> 部分，也有疑似纰漏的地方：<br> <img src="/2019/12/16/Lagrange/c.png" width="500"></p></li></ol><p>虽然 IEEE 论文有瑕疵，但是后续的会以它的为主，第一篇信誉度下滑的中文论文暂且放下。<br> 邹永贵等:带多约束条件的最优路径选择算法研究 中对我最大的启示不是论文本身提出的观点，而是它提到了这篇 IEEE 论文中确确实实是采用次梯度下降法寻找最优参数，并采用上下界相等的停止原则来获得最优的解</p><h2 id="数学抽象">数学抽象</h2><p>现在要做的就是用前面介绍的线性变换关系，将 QoS 算法抽象成原来的拉格朗日松弛技术下的数学表达。<br> 这一步在论文中都是跳过的，笔者猜想这是默认阅读论文的人都是学过运筹学或者最优化理论的。作为深入浅出的博客文章，我会对加上这一部分进行介绍。</p><h3 id="最值问题">最值问题</h3><p>原本的拉格朗日松弛法解决的问题是：<br> $$<br> \begin{aligned}<br> z_{1}= \min c^{T} x \\<br> s.t. Ax \geq b \\<br> x=[x_1, x_2, …, x_n]^T<br> \end{aligned}<br> $$<br> 其中 $x$ 是一个列向量，这是之前讨论的结果，也是为这里的工作埋下的伏笔。<br> 前面提到的把 $c=[c_1, c_2, …, c_m]$，字母c 可以理解成 cost（代价），也是伏笔。</p><h3 id="图">图</h3><p>网络可以看成是一张图，每一个结点V（vertex）对应一个网络设备或是终端，边（Edge）的权重对应连路上的一些参数，比如时延（delay）、代价（cost）。之前也提到乘性参数可通过取对数变为加性参数，所以可以统一处理。<br> <img src="/2019/12/16/Lagrange/graph.png" width="400"></p><h3 id="最小代价和时延约束">最小代价和时延约束</h3><p>而从一个结点到另一个结点的最小代价可以用图论中的 Dijkstra 算法得到。最短路径 $p$ 可以用一个列向量表示，为了和参数（比如代价）元素个数保持一致，路径用边作为向量的元素。故：最短路径 $p = [e_1, e_2, …, e_m]$，路径上的边权 $c=[c_1, c_2, …, c_m]$。现在得到一个非常重要的式子，通过多因素积累单因素得到所有边权的总和：<br> $$<br> c^T p = \min _{p \in P^{\prime}(s, t)} \sum_{e \in p} c(e) = Cost<br> $$<br> $P^{\prime}(s, t)$表示从结点 s，到结点 t 所有的路径。<br> 同样的道理，时延可以表示成为：<br> $$<br> d^T p = \sum_{e \in p} d(e) = Delay<br> $$<br> 原来的时延约束条件对应的表达式为：<br> $$<br> \sum_{e \in p} d(e)\le \Delta_{delay}<br> $$<br> 总的来说，已经将时延约束下最小代价的 QoS 转成适用于拉格朗日松弛法的表达式子。<br> $$<br> \begin{aligned}<br> z_{1}= \min c^{T} x \Rightarrow \min _{p \in P^{\prime}(s, t)} \sum_{e \in p} c(e) \\<br> s.t. Ax \geq b \Rightarrow \sum_{e \in p} d(e)\le \Delta_{delay}\\<br> x=[x_1, x_2, …, x_n]^T \Rightarrow p = [e_1, e_2, …, e_m]<br> \end{aligned}<br> $$</p><h3 id="多约束条件">多约束条件</h3><p>多约束条件是类似的。<br> $$<br> \begin{array}{c}{\min c§} \\<br> s.t. \\<br> w_{1}§ \leqslant M_{1} \\<br> {w_{2}§ \leqslant M_{2}} \\<br> {\vdots} \\<br> {w_{k}§ \leqslant M_{k}}\end{array}<br> $$</p><h2 id="基于拉格朗日松弛的-QoS">基于拉格朗日松弛的 QoS</h2><p>原始问题的困难点在于代价和时延没有关系，所以要找到满足时延条件的代价最小的路径，只能把全部路径遍历一遍。是 NP 完全问题。</p><h3 id="构造拉格朗日松弛式及其性质">构造拉格朗日松弛式及其性质</h3><h4 id="Claim-1">Claim 1</h4><p>$$<br> \begin{array}{l}<br> {\text { Claim 1: Let }} \\<br> {\qquad L(\lambda):=\min \left [ c_{\lambda}§: p \in P(s, t)\right ]-\lambda \Delta_{\text {delay }}} \\<br> {\leq c - \lambda\left(p^{* }\right)-\lambda \Delta_{\text {delay}}} \\<br> {=c\left(p^{* }\right)+\lambda\left(d\left(p^{* }\right)-\Delta_{\text {delay}}\right) \leq c\left(p^{*}\right)}<br> \end{array}<br> $$</p><p>这个 claim 告诉我们两个事情。<br> 第一个事情是（第一行）：<br> $$<br> \begin{aligned}<br> \min _{p \in P^{\prime}(s, t)} \sum_{e \in p} c(e) -\lambda (\sum_{e \in p} d(e) - \Delta_{delay})\\<br> \Rightarrow L(\lambda) = c_§ - \lambda(d§-\Delta_{delay})<br> \end{aligned}<br> $$<br> $L(\lambda)$ 就是之前的 $z_1(\lambda)$.<br> 虽然矩阵乘法的意义没有变，但是 $\lambda \not= 0$ 时，$c_{\lambda}§$ 对应的已经不是原本意义下的最小代价或者时延。解释如下：<br> $$<br> L(\lambda) = c_§ - \lambda(d§-\Delta_{delay}) = (c_§ - \lambda d§) -\lambda \Delta_{delay}<br> $$<br> $$<br> \begin{array}{l}{<br> \text { 令 }}<br> (c_§ - \lambda d§)=c_{\lambda}<br> \text{，则}<br> L(\lambda):=\min \left{c_{\lambda}§: p \in P(s, t)\right}-\lambda \Delta_{delay}<br> \end{array}<br> $$<br> 这意味着拉格朗日松弛式构造的函数 $L(\lambda)$ 中的 $c(p_{\lambda})$ 对应的边的权重是由原来的代价和时延按照 $\lambda : 1$ 混合而成。（其实如果对拉格朗日松弛法熟悉的人早就看透了这一点）。<br> 第二个事情（不等号放缩）：<br> 通过不等式放缩得到了 $L_{\lambda}$ 的上界，这成为后面选用 Polyak’ rule 作为步长选取的方案做了铺垫。</p><h4 id="Claim-2">Claim 2</h4><p>$$<br> \begin{array}{l}<br> {\text { Claim 2: } L \text { is a concave piecewise linear function, namely }} \\<br> {\text { the minimum of the linear functions } c§+\lambda\left(d§-\Delta_{\text {delay}}\right)} \\<br> {\text {for all } p \in P(s, t) .}<br> \end{array}<br> $$</p><p><code>concave piecewise linear function</code>: 凹分段线性函数<br> 这个也告诉我们两件事情，一个是作为分段线性函数，寻找 $\lambda$ 的方法是用次梯度下降法，而非梯度下降法。在没有看这篇文章的时候我曾经选用了梯度法（无法求导）。另一件事情是它是凹函数，所以在用“次梯度下降法”（这里也许可以称为是次梯度上升法），注意是往次梯度上升的方向靠近，不要思维定式地下降。</p><h4 id="Claim-3">Claim 3</h4><p>$$<br> \begin{array}{l}{\text { Claim 3: For any } \lambda \geq 0 \text { and } c_{\lambda} \text { -minimal path } p_{\lambda}, d\left(p_{\lambda}\right) \text { is a }} \\ {\text { supgradient of } L \text { in the point } \lambda .}\end{array}<br> $$</p><p>这个 claim 告诉我们一个非常非常重要的事情，它直接把一个合适的次梯度告诉我们了：$d(p_{\lambda})$.<br> 有兴趣的可以证明一下。</p><h4 id="Claim-4">Claim 4</h4><p>$$<br> \begin{array}{l}<br> {\text { Claim 4: Whenever } \lambda&lt;\lambda^{* }, \text { then } d\left(p_{\lambda}\right) \geq \Delta_{\text {delay}} and , if } \\<br> {\lambda&gt;\lambda^{*}, \text { then } d\left(p_{\lambda}\right) \leq \Delta_{\text {delay }} \text { for each } c_{\lambda \text { -minimal path } p_{\lambda}}}<br> \end{array}<br> $$</p><p><s>实话是，我在写这篇文章的时候才理解它想表达的意思。</s>（现在都还没有懂）<br> 其中$L^{* }:=\max _{\lambda \geq 0} L(\lambda), \lambda^*$是使该式子成立的一个参数。<br> 既然 $L(\lambda)$ 中的 $c(p_{\lambda})$ 对应的边的权重是由原来的代价和时延按照 $\lambda : 1$ 混合而成，那么我们可以想象得到最优解在，差不多刚刚好满足时延条件下时的最小代价。如果 $\lambda$ 过小，$c(p_{\lambda})$ 会因为时延部分给的太少而不够大；如果 $\lambda$ 过大，拉格朗日乘子和乘数的乘积会很小（负数），所以是一个凹函数。<br> $\lambda$</p><h4 id="Claim-5">Claim 5</h4><p>$$<br> \begin{array}{l}{\text { Claim } 5: \text { A value } \lambda \text { maximizes the function } L(\lambda) \text { if and only }} \\ {\text { if there are paths } p_{c} \text { and } p_{d} \text { which are both } c_{\lambda} \text { -minimal and for }} \\ {\text { which } d\left(p_{c}\right) \geq \Delta_{\text {delay}} \text {and } d\left(p_{d}\right) \leq \Delta_{\text {delay}} }\end{array}.<br> $$</p><p>claim 5 告诉我们存在最小解 λ 的充要条件是：最小时延小于限制条件并且最小代价的时延大于等于时延（否则不需要松弛了即有最优解）。<br> 最小时延和最小代价可以发生在一条路径上。<br> (这个定理千万千万不要误会不要误会)</p><h4 id="Claim-6">Claim 6</h4><p>$$<br> \begin{array}{l}<br> {\text { Claim } 6: \text { Let } 0 \leq \lambda_{1}&lt;\lambda_{2}, \text { and } p_{\lambda_{1}}, p_{\lambda_{2}} \in P(s, t) \lambda_{1}-} \\ {\text { minimal and } \lambda_{2} \text { -minimal paths. Then } c\left(p_{\lambda_{1}}\right) \leq c\left(p_{\lambda_{2}}\right) \text { and }} \\ {d\left(p_{\lambda_{1}}\right) \geq d\left(p_{\lambda_{2}}\right)}<br> \end{array}<br> $$</p><p>λ 增加，意味着时延的要求更高。满足条件的最优路径，原本的时延会变小，代价会增大。<br> 所以随着 λ 增加，原本路径代价变化，时延小的路径的总体代价逐渐减小，晋升为代价最小路径。</p><h3 id="算法流程">算法流程</h3><p>完事具备，只欠东风:<br> $$<br> \begin{array}{l}<br> { \text { procedure LARAC( }\left.s, t, c, d, \Delta_{\text {delay }}\right)} \\<br> {p_{c}:=\text { Dijkstra }(s, t, c)} \\<br> {\text { if } d\left(p_{c}\right) \leq \Delta_{delay}\text { then return } p_{c}} \\<br> {\left.p_{d}:=\text { Dijkstra } (s, t, d\right)} \\<br> {\text { if } d\left(p_{d}\right)&gt;\Delta_{\text {delay }}} \\<br> {\text { then return “There is no solution”}}\\<br> {\text { repeat }} \\<br> { \begin{aligned}<br> \lambda &amp;:=\frac{c\left(p_{c}\right)-c\left(p_{d}\right)}{d\left(p_{d}\right)-d\left(p_{c}\right)} \\<br> {r:=\text { Dijkstra }(s, t, c_{\lambda})} \\<br> \text { if } c_{\lambda}®=c_{\lambda}\left(p_{d}\right) \text { then return } p_{d}\\<br> \text { else if } d® \leq \Delta_{delay}\text { then } p_{d}:=r \\<br> \text {else} ; p_c := r\\<br> {\text { end repeat }}\\<br> \text { end procedure }<br> \end{aligned}}<br> \end{array}<br> $$<br> where Dijkstra(s,t,c) returns a c-minimal path between the nodes s and t.</p><h3 id="解读">解读</h3><h4 id="特殊情况处理">特殊情况处理</h4><p>根据前面的 claim 5，排除了最小时延大于限制条件的情况。同时如果在在最小代价的情况下已经满足时延条件，那就不必用拉格朗日松弛法，直接输出。</p><h4 id="次梯度下降法">次梯度下降法</h4><p>根据 Claim 2，我们知道 $L(\lambda)$ 是凹分段线性函数；根据 Claim 1，我们知道 $L(\lambda)$ 的上界是任意的一条路径的代价 $c(p^* )$. 在知道上界的情况下，我们自然想到用 Polyak’ rule。<br> 步长为：<br> $$<br> {\qquad \alpha_{k}=\frac{f\left(x^{(k)} \right)-f^{ \star}}{\left | g<sup>{(k)}\right|_{2}</sup>{2}}}<br> $$<br> 从算法流程中我们可以看出来，这里取的路径 $p^*$ 是最小时延路径 $c(p_d)$.</p><p>根据 claim 3，取 $d(p_{\lambda})$ 作为一个合适的次梯度.<br> // 之后那么 $\lambda$ 怎么用那个公式反复迭代至今没有推送算出来，但是八九不离十。<br> 最终结束的条件是我们在介绍拉格朗日松弛法停止原则的第三条，上界等于下界。这里的上界是最小时延路径 $c(p_d)$，下界是每次 $L(\lambda)$ 的一个可行解。</p><h1>带多约束条件</h1><p>在 邹永贵等:带多约束条件的最优路径选择算法研究 中对Dijksra算法进行了适当的改进, 定义了一个选取规则, 从而使算法接近最优解。<br> 先用拉格朗日松弛消去约束, 并求得问题的下界。由于常用的迭代方法效果不好, 提出了一种新的迭代方法。</p><h1>参考材料</h1><h2 id="参考文献">参考文献</h2><p>[1]Juttner, A., Szviatovski, B., Mecs, I., Rajko, Z… Lagrange relaxation based method for the QoS routing problem[P]. INFOCOM 2001. Twentieth Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings. IEEE,2001.<br> [2]何涛,王锁萍,张明.一种基于拉格朗日松弛法的QoS路由算法[J].电路与系统学报,2010,15(01):37-40.<br> [3]查益,江昊,晏蒲柳,周建国,周小平,徐武平.基于拉格朗日松驰的多约束QoS路由算法[J].计算机应用研究,2005(01):47-49.<br> [4]Winston，W.L.运筹学：数学规划（第3版）[M].北京：清华大学出版社，2004.01<br> [5]黄廷祝,成孝予.线性代数与空间解析几何（第四版）[M].高等教育出版社，2015.09</p><h1>参考网页</h1><ol><li><a href="https://link.zhihu.com/?target=https%3A//youtu.be/v2uHiBH85mk">7分钟带你入门线性代数+微积分</a></li><li><a href="https://blog.csdn.net/qq_39521554/article/details/81877845" target="_blank" rel="noopener">什么是次梯度（次导数）</a></li><li><a href="https://wenku.baidu.com/view/550fe416abea998fcc22bcd126fff705cd175c56.html" target="_blank" rel="noopener">拉格朗日松弛</a></li><li><a href="https://blog.csdn.net/qq_32742009/article/details/81704139" target="_blank" rel="noopener">【机器学习】次梯度（subgradient）方法</a></li><li>subgrad_method_slide - Stanford University</li></ol></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------ The end ------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2019/12/16/Lagrange/">【深入浅出】基于拉格朗日松弛法的多约束 QoS 路由算法</a></p><p><span>文章作者:</span><a href="/" title="访问 Andy Wu 的个人博客">Andy Wu</a></p><p><span>发布时间:</span>2019年12月16日 - 00:12</p><p><span>最后更新:</span>2020年03月31日 - 20:03</p><p><span>原始链接:</span><a href="/2019/12/16/Lagrange/" title="【深入浅出】基于拉格朗日松弛法的多约束 QoS 路由算法">https://zer0-nu1l.github.io/2019/12/16/Lagrange/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://zer0-nu1l.github.io/2019/12/16/Lagrange/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><footer class="post-footer"><div class="post-tags"><a href="/tags/QoS/" rel="tag"><i class="fa fa-tag"></i> QoS</a><a href="/tags/Lagrange-Relaxation/" rel="tag"><i class="fa fa-tag"></i> Lagrange Relaxation</a><a href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag"><i class="fa fa-tag"></i> 矩阵</a><a href="/tags/%E6%AC%A1%E6%A2%AF%E5%BA%A6/" rel="tag"><i class="fa fa-tag"></i> 次梯度</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/12/08/SDN-DDoS/" rel="next" title="SDN-DDoS Question & Consult"><i class="fa fa-chevron-left"></i> SDN-DDoS Question & Consult</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2020/01/21/KaliSSH%E9%85%8D%E7%BD%AE/" rel="prev" title="VSCode Remote-SSH Kali 配置">VSCode Remote-SSH Kali 配置<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/uploads/Profile.jpg" alt="Andy Wu"><p class="site-author-name" itemprop="name">Andy Wu</p><p class="site-description motion-element" itemprop="description">Cover the face and straight ahead.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">20</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">26</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ZER0-Nu1L" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:wcb534813346@126.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Blogroll</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://ff-0xff.github.io/" title="ff-0xff" target="_blank">ff-0xff</a></li><li class="links-of-blogroll-item"> <a href="http://fitz.hasentu.com/" title="五维生物" target="_blank">五维生物</a></li><li class="links-of-blogroll-item"> <a href="https://gemini-lin.github.io/" title="Gemini-Lin" target="_blank">Gemini-Lin</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">2.</span> <span class="nav-text">线性变换关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单因素积累单因素-标量×标量"><span class="nav-number">2.1.</span> <span class="nav-text">单因素积累单因素 - 标量×标量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多因素累积单因素-向量×向量"><span class="nav-number">2.2.</span> <span class="nav-text">多因素累积单因素 - 向量×向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多因素累积多因素-矩阵×向量"><span class="nav-number">2.3.</span> <span class="nav-text">多因素累积多因素 - 矩阵×向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批量多因素积累多因素-矩阵×矩阵"><span class="nav-number">2.4.</span> <span class="nav-text">批量多因素积累多因素 - 矩阵×矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">2.4.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性变化关系总结"><span class="nav-number">2.5.</span> <span class="nav-text">线性变化关系总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">3.</span> <span class="nav-text">次梯度法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#次梯度的概念"><span class="nav-number">3.1.</span> <span class="nav-text">次梯度的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本次梯度算法"><span class="nav-number">3.2.</span> <span class="nav-text">基本次梯度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">迭代方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步长的选取"><span class="nav-number">3.2.2.</span> <span class="nav-text">步长的选取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#停止条件"><span class="nav-number">3.2.3.</span> <span class="nav-text">停止条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">4.</span> <span class="nav-text">拉格朗日松弛法（Lagrange Relaxation）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#要解决的问题"><span class="nav-number">4.1.</span> <span class="nav-text">要解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展"><span class="nav-number">4.1.1.</span> <span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">4.2.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思想"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择最优的拉格朗日乘子"><span class="nav-number">4.2.2.</span> <span class="nav-text">选择最优的拉格朗日乘子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#梯度法"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">梯度法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#次梯度法"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">次梯度法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#步长的选择"><span class="nav-number">4.2.2.2.1.</span> <span class="nav-text">步长的选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#停止条件-v2"><span class="nav-number">4.2.2.2.2.</span> <span class="nav-text">停止条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用次梯度法于拉格朗日松弛"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">应用次梯度法于拉格朗日松弛</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法步骤："><span class="nav-number">4.2.2.3.1.</span> <span class="nav-text">算法步骤：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单应用"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">简单应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用途"><span class="nav-number">4.3.</span> <span class="nav-text">用途</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">5.</span> <span class="nav-text">QoS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QoS-和-拉格朗日松弛法的关系"><span class="nav-number">5.1.</span> <span class="nav-text">QoS 和 拉格朗日松弛法的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QoS-问题简介"><span class="nav-number">5.1.1.</span> <span class="nav-text">QoS 问题简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传统算法和拉格朗日松弛法"><span class="nav-number">5.1.2.</span> <span class="nav-text">传统算法和拉格朗日松弛法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#论文介绍"><span class="nav-number">5.2.</span> <span class="nav-text">论文介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#论文缺憾"><span class="nav-number">5.2.1.</span> <span class="nav-text">论文缺憾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IEEE-论文"><span class="nav-number">5.2.2.</span> <span class="nav-text">IEEE 论文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学抽象"><span class="nav-number">5.3.</span> <span class="nav-text">数学抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最值问题"><span class="nav-number">5.3.1.</span> <span class="nav-text">最值问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图"><span class="nav-number">5.3.2.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小代价和时延约束"><span class="nav-number">5.3.3.</span> <span class="nav-text">最小代价和时延约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多约束条件"><span class="nav-number">5.3.4.</span> <span class="nav-text">多约束条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于拉格朗日松弛的-QoS"><span class="nav-number">5.4.</span> <span class="nav-text">基于拉格朗日松弛的 QoS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造拉格朗日松弛式及其性质"><span class="nav-number">5.4.1.</span> <span class="nav-text">构造拉格朗日松弛式及其性质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Claim-1"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">Claim 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Claim-2"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">Claim 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Claim-3"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">Claim 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Claim-4"><span class="nav-number">5.4.1.4.</span> <span class="nav-text">Claim 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Claim-5"><span class="nav-number">5.4.1.5.</span> <span class="nav-text">Claim 5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Claim-6"><span class="nav-number">5.4.1.6.</span> <span class="nav-text">Claim 6</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法流程"><span class="nav-number">5.4.2.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解读"><span class="nav-number">5.4.3.</span> <span class="nav-text">解读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊情况处理"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">特殊情况处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#次梯度下降法"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">次梯度下降法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">6.</span> <span class="nav-text">带多约束条件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">7.</span> <span class="nav-text">参考材料</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">7.1.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">8.</span> <span class="nav-text">参考网页</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Andy Wu &nbsp | &nbsp</span><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_pv">Number of visitors:<span id="busuanzi_value_site_pv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">57.8k</span></div></div><div class="theme-info"><div class="powered-by"></div><span class="post-count"></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script src="/js/src/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"b559026a8469cfafb7e3",clientSecret:"68757dba62da9ddd3078e0b24c9c146b555deecc",repo:"ZER0-Nu1L.github.io",owner:"ZER0-Nu1L",admin:["ZER0-Nu1L"],id:md5(location.pathname),distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/custom.js"></script></body></html>